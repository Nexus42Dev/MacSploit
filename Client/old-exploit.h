//
// Created by Nexus Pancakes on 6/11/2022.
//

#ifndef CLIENT_EXPLOIT_H
#define CLIENT_EXPLOIT_H
#include <vector>
#include <string>
#include <unistd.h>
#include <fstream>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <Luau/Compiler.h>
#include <Luau/BytecodeBuilder.h>
#include <unordered_map>
#include <semaphore.h>
#include <curl/curl.h>
#include <uuid/uuid.h>

#include "sha1.hpp"

static void dylib_entry() __attribute__((constructor));

enum ENC_TYPE {
    ENC_ADD,
    ENC_XOR,
    ENC_SUBPTR,
    ENC_SUBVAL
};

#define LUA_REGISTRYINDEX (-10000)
#define LUA_ENVIRONINDEX (-10001)
#define LUA_GLOBALSINDEX (-10002)
#define lua_upvalueindex(i) (LUA_GLOBALSINDEX - (i))
#define rbx_pop(L, n) (*rbx_settop)(L, -(n)-1)

#define LUA_TBOOLEAN 1
#define LUA_TSTRING 5
#define LUA_TUSERDATA 10
#define LUA_TBUFFER 8
#define LUA_TTABLE 9
#define LUA_TNUMBER 4
#define LUA_TTHREAD 7
#define LUA_TFUNCTION 6
#define LUA_TUPVAL 12
#define LUA_TNIL 0
#define LUA_TNONE -1

#define PROTO_ENC ENC_SUBVAL
#define PROTOS_ENC ENC_SUBVAL
#define FUNCTION_ENC ENC_SUBVAL
#define CONTINUE_ENC ENC_SUBPTR
#define CONSTANT_ENC ENC_XOR

#define PROTO_DEC(a) *(uint64_t*)a - a //"function":
#define PROTOS_DEC(a) *(uint64_t*)a - a //"protos"
#define FUNCTION_DEC(a) *(uint64_t*)a - a //ipairs -> pushcclosure
#define CONSTANT_DEC(a) *(uint64_t*)a + a //deserialize, third new array call

const char* anon = R"(⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣷⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⠛⠻⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣁⠀⠀⠀⠀⣀⣤⣶⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⠛⠉⠛⠶⠀⠀⢐⠿⠋⠀⢨⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢷⣿⣿⣶⠀⠀⠉⢶⣿⣿⠿⢿⣿⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣶⡶⠂⠀⣀⠀⢀⡄⠐⢲⡾⣻⣿⣿⣿⠇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣯⢿⡶⣶⣿⣟⣿⡶⠶⣿⢣⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⣾⣿⣿⣿⣧⠛⠒⠠⣤⣤⠶⠾⢣⣿⣿⣿⣿⣿⣤⣀⠀⠀⠀
⢀⣠⣤⣶⣶⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⢿⣿⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 [Abyss] Digital Software
    -> Developed by milo

)";

std::string init_script = R"(
getgenv().hookfunction = function(func, hook)
    if iscclosure(func) or iscclosure(hook) then
        table.insert(getreg(), hook)
        return swapfunction(func, newcclosure_s(hook))
    end

    return hookfunction_c(func, hook)
end

getgenv().hookfunc = hookfunction
getgenv().hookmetamethod = newcclosure(function(instance, metamethod, closure)
    local mt = getrawmetatable(instance)
    old_metaclosure = hookfunction(mt[metamethod], closure)
    return old_metaclosure
end)

getgenv().unsafehookmetamethod = newcclosure(function(instance, metamethod, closure)
    local mt = getrawmetatable(instance)
    setreadonly(mt, false)

    old_metaclosure = mt[metamethod]
    mt[metamethod] = closure

    setreadonly(mt, true)
    return old_metaclosure
end)

function reverse(myTable)
	if myTable and #myTable > 1 then
		local temp = nil
		for n = 1,math.floor(#myTable/2) do
			temp = myTable[n]
			myTable[n] = myTable[#myTable-(n-1)]
			myTable[#myTable-(n-1)] = temp
		end 
	end

    return myTable
end

getgenv().randomstring = function(length)
    local str = ""
    for _ = 1, length or 20 do
        local type = math.random(1,3)
        if type == 1 then
            str = str .. string.char(math.random(97,122)) -- Lowercase
        elseif type == 2 then
            str = str .. string.char(math.random(65,90)) -- Uppercase
        elseif type == 3 then
            str = str .. string.char(math.random(48,57)) -- Numbers
        end
    end
    return str
end

getgenv().randomString = randomstring
getgenv().clonetable = newcclosure(function(tbl)
    local clone = {}
    for i, v in tbl do
        clone[i] = v
    end

    return clone
end)

getgenv().cloneref = function(...)
    return ...
end

getgenv().sethiddenproperty = function(inst, name, val)
    console_print('Pretended to set a hidden property of '.. inst.Name.. ' xd: '.. name.. ' to '.. tostring(val))
end

getgenv().getcallingscript = newcclosure(function(level)
    level = level and level + 1 or 1
    local func = setfenv(level, getfenv(level))
    return getfenv(func).script
end)

getgenv().quickLoad = newcclosure(function(url)
    return loadstring(game:HttpGet(url))()
end)

getgenv().getsenv = function(parameter)
    for i,v in pairs(debug.getregistry()) do
        if type(v) == "function" and islclosure(v) and getfenv(v).script == parameter then
            return getfenv(v)
        end
    end
end

getgenv().getscriptclosure = function(script)
    for _, v in getreg() do
        if type(v) ~= 'function' then continue end
        if not islclosure(v) then continue end
        if getfenv(v).script ~= script then continue end
        return v
    end
end

local script_env = Instance.new("LocalScript")
script_env.Name = randomstring()
getgenv().script = script_env

getgenv().rconsolename = function(name) console_print('-- '.. name.. ' --') end
getgenv().rconsolewarn = function(text) console_print('WARN: '.. text) end
getgenv().rconsoleerr = function(text) console_print('ERROR: '.. text) end
getgenv().rconsoleprint = console_print

getgenv().getthreadidentity = getidentity
getgenv().setthreadidentity = setidentity
getgenv().set_fps_cap = setfpscap

getgenv().isourclosure = isexecutorclosure
getgenv().is_synapse_function = isexecutorclosure
getgenv().isexploitclosure = isexecutorclosure
getgenv().isexecutorfunction = isexecutorclosure
getgenv().isexploitfunction = isexecutorclosure
getgenv().isourfunction = isexecutorclosure
getgenv().isgameclosure = function(cl)
    return not isexecutorclosure(cl)
end

getgenv().newlclosure = function(cl)
    return function(...)
        return cl(...)
    end
end

getgenv().getinstances = function()
    local insts = {}
    for _, v in getreg() do
        if type(v) == 'table' then
            for _, s in pairs(v) do
                if typeof(s) == 'Instance' then
                    table.insert(insts, s)
                end
            end
        end
    end

    return insts
end

getgenv().getnilinstances = function()
    local insts = {}
    for _, v in getreg() do
        if type(v) == 'table' then
            for _, s in pairs(v) do
                if typeof(s) == 'Instance' and s.Parent == nil then
                    table.insert(insts, s)
                end
            end
        end
    end

    return insts
end

getgenv().firetouchinterest = function(part, transmitter, toggle)
    if toggle ~= 0 then return end
    for _, v in pairs(getconnections(transmitter.Touched)) do
        v.Function(part);
    end
end

getgenv().fireproximityprompt = function(Obj, Amount, Skip)
	assert(typeof(Obj) == "Instance", "invalid argument #1 to 'fireproximityprompt' (ProximityPrompt expected, got " .. type(Spoof) .. ") ")
	assert(Obj.ClassName == "ProximityPrompt", "invalid argument #1 to 'fireproximityprompt' (ProximityPrompt expected, got " .. type(Spoof) .. ") ")
    assert(type(Amount) == "number", "invalid argument #2 to 'fireproximityprompt' (number expected, got " .. type(Amount) .. ") ", 2)
	Amount = Amount or 1
    local PromptTime = Obj.HoldDuration
    if Skip then
        Obj.HoldDuration = 0
    end
    for i = 1, Amount do
        Obj:InputHoldBegin()
        if not Skip then
            wait(Obj.HoldDuration)
        end
        Obj:InputHoldEnd()
    end
    Obj.HoldDuration = PromptTime
end

getgenv().async_request = function(options)
    console_print(options.Url)
    if string.find(options.Url, 'webhooks') then
        console_print(options.Body)
    end

    rawset(options.Headers, 'User-Agent', nil)
	local Event = Instance.new("BindableEvent")
	local RequestInternal = game:GetService("HttpService").RequestInternal
	local Request = RequestInternal(game:GetService("HttpService"), options)
	
	local Response
	Request:Start(function(state, response)
		Response = response
		Event:Fire()
	end)
	
	Event.Event:Wait()
    console_print('Successful Request.')
    if string.find(options.Url, 'ink/tokenValid/') then
        console_print('work.ink bypass (milo).')
        Response.Body = '{"valid":true}'
    end

	return Response
end

getgenv().http_request = newcclosure(function(options)
    if not options.Headers then
        rawset(options, 'Headers', {})
    end
    
    local fingerprint = gethwid()
    assert(options.Url, 'Failed to retrieve URL property.')
    rawset(options, 'Method', string.upper(options.Method or "Get"))
    rawset(options.Headers, 'Macsploit-Fingerprint', fingerprint)
    rawset(options.Headers, 'Hydrogen-Fingerprint', fingerprint)

    if options.Cookies then
        local cookies = ''
        for i, v in options.Cookies do
            cookies = cookies.. i.. '='.. v.. ';'
        end
        
        rawset(options.Headers, 'Cookie', cookies)
        rawset(options, 'Cookies', nil)
    end
    
    local Response = async_request(options)
    task.wait()
    
    Response.Cookies = {}
    if Response.Headers and Response.Headers['Cookie'] then
        for cookie in string.gmatch(Response.Headers['Cookie'], '([^;]+)') do
            local data = {}
            for str in string.gmatch(cookie, '([^=]+)') do
                table.insert(data, str)
            end
            
            Response.Cookies[Data[1]] = Data[2]
        end
    end
    
    return Response
end)

getgenv().gethui = function()
  return game.CoreGui
end

getgenv().request = http_request
getgenv().http = {
    ['request'] = http_request
}

getgenv().getsignalfuncs = function(signal)
    local connection = signal:Connect(function() return end)
    local indexes = getallindexes(connection)
    local registry = getreg()
    local functions = {}
    
    for _, i in indexes do
        table.insert(functions, registry[i])
    end
    
    connection:Disconnect()
    return functions
end

getgenv().firesignal = function(signal, ...)
    local connections = getconnections(signal)
    for _, connection in connections do
        connection.Function(...)
    end
end

getgenv().getconnections = function(signal)
    local connection = signal:Connect(function() return end)
    local connections = getconnections_c(connection)
    connection:Disconnect()
    return connections
end

getgenv().fireclickdetector = function(clickdetector, distance)
    fireclickdetector_c(clickdetector, game.Players.LocalPlayer, distance)
end

getgenv().syn = {
    ['protect_gui'] = function() return end,
    ['unprotect_gui'] = function() return end,
    ['queue_on_teleport'] = queue_on_teleport,
    ['request'] = http_request
}

getgenv().queueonteleport = queue_on_teleport
--getgenv().getscriptclosure = function(script)
--    return getscriptfromname(script:GetFullName())
--end

getgenv().httpget_async = function(url, async)
    local fingerprint = gethwid()
    local Response = async_request({
        Url = url:gsub('\n', ''),
        Method = "GET",
        Headers = {
            ['Hydrogen-Fingerprint'] = fingerprint,
            ['Macsploit-Fingerprint'] = fingerprint
        }
    }).Body

	task.wait()
	return Response
end

getgenv().get_objects = function(...)
    return { game:GetService("InsertService"):LoadLocalAsset(...) }
end

local old_namecall
old_namecall = hookmetamethod(game, '__namecall', function(self, ...)
    if not checkcaller() then return old_namecall(self, ...) end
    local method = getnamecallmethod()

    if method == "HttpGet" or method == "HttpGetAsync" then
        return httpget_async(...)
    end

    if method == "GetObjects" then
        return get_objects(...)
    end

    return old_namecall(self, ...)
end)

getgenv().httpget_async_index = function(self, ...)
    return httpget_async(...)
end

getgenv().get_objects_index = function(self, ...)
	return get_objects(...)
end

local old_index
old_index = hookmetamethod(game, '__index', function(self, idx)
    if not checkcaller() or self ~= game then return old_index(self, idx) end
    if idx == "HttpGet" or idx == "HttpGetAsync" then
        return httpget_async_index
    end

    if idx == "GetObjects" then
        return get_objects_index
    end

    local success, value = pcall(function()
        local Service = game:GetService(idx)
        if Service and type(Service) ~= 'string' then
            return true
        end

        return false
    end)

    if not success or not value then
        return old_index(self, idx)
    end

    return game:GetService(idx)
end)

local roblox_focused = false
game.Changed.Connect(game.UserInputService.WindowFocusReleased, function()
    roblox_focused = false
end)

game.Changed.Connect(game.UserInputService.WindowFocused, function()
    roblox_focused = true
end)

getgenv().isrbxactive = newcclosure(function()
    return roblox_focused
end)

oldRequire = require
getgenv().require = newcclosure(function(...)
    identity = getidentity()
    setidentity(2)
    
    local result = oldRequire(...)
    setidentity(identity)
    return result
end)

oldGameRequire = getrobloxenv().require
getrobloxenv().require = newcclosure(function(...)
    setidentity(2)
    return oldGameRequire(...)
end)

getgenv().getscriptclosure = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    return script_dict[script][1]
end

getgenv().getscriptbytecode2 = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')

    local bytecode_s = script_dict[script][2]
    local bytecode_c = {}

    for v in string.gmatch(bytecode_s, ".") do
        table.insert(bytecode_c, string.byte(v))
    end

    return bytecode_c
end

getgenv().getscriptbytecode = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    return script_dict[script][2]
end

-- Testing
spawn(function()
    getgenv().script_dict = {}
    getgenv().script_buffer = {}
    while true do task.wait()
        if #script_buffer == 0 then continue end
        for _, v in script_buffer do
            local data = string.split(v[1], '.')
            local current_parent = game
            local current_child

            for _, v in data do
                current_child = current_parent:FindFirstChild(v)
                if not current_child then break end
                current_parent = current_child
            end

            if not current_child then continue end
            script_dict[current_child] = { v[2], v[3] }
            table.remove(script_buffer, table.find(script_buffer, v))
        end
    end
end)
)";

std::string extra_stuff = R"(
local Remote = Instance.new('RemoteEvent')
local oldFireServer

oldFireServer = hookfunction(Remote.FireServer, function(remote, ...)
    local sdata = remote:GetFullName().. ' - FireServer'.. '\n'
    for i, v in {...} do
        sdata = sdata.. typeof(v).. ' - '.. tostring(i).. ': '.. tostring(v).. '\n'
        if type(v) == 'table' then
            for i2, v2 in v do
                sdata = sdata.. typeof(v2).. ' - '.. tostring(i2).. ': '.. tostring(v2).. '\n'
            end
        end
    end
    
    logscfds(sdata)
    return oldFireServer(remote, ...)
end)

local hooked_namecall
hooked_namecall = hookmetamethod(game, '__namecall', function(self, ...)
    local method = getnamecallmethod()
    if method:lower() == 'invokeserver' or method:lower() == 'fireserver' then
        local sdata = self.Name.. ' - '.. method.. '\n'

        for i, v in {...} do
            sdata = sdata.. typeof(v).. ' - '.. tostring(i).. ': '.. tostring(v).. '\n'
            if type(v) == 'table' then
                for i2, v2 in v do
                    sdata = sdata.. typeof(v2).. ' - '.. tostring(i2).. ': '.. tostring(v2).. '\n'
                end
            end
        end

        logscfds(sdata)
    end

    return hooked_namecall(self, ...)
end)
)";

namespace offsets {
    const int jobs_start = 0x158;
    const int jobs_end = 0x160;
    const int jobs_offset = 0x10;

    int state_env = 0x0;
    int state_callinfo = 0x28; //"table overflow" -> func, func in func then first offset.
    const int state_top = 0x18;
    const int state_base = 0x8;

    namespace callinfo {
        const int func_offset = 0x10; //"table overflow" -> func, func in func then second offset.
    }

    namespace table {
        const int isreadonly_offset = 0x3;
    }

    namespace hybridscriptsjob {
        const int script_context = 0x3b;
    }

    namespace global {
        const int global_offset = 0x28;
    }

    namespace signal {
        const int next = 0x20;
        const int state = 0x28;
    }

    namespace proto {
        const int constants = 0x20; //Deserialize -> second new array call
        const int sizek = 0x88; //Deserialize -> Offset right above proto->k;

        const int protos = 0x8; //"protos"
        const int sizep = 0xa0; //"protos" -> if (proto->sizep)
        const int nupvalues = 0x90; //Deserialize -> 4th newarray call after switch statement, above
    }
}

namespace roblox_structs {
    #define CommonHeader uint8_t tt; uint8_t marked; uint8_t white

    struct GCObject {
        CommonHeader;
    };

    struct Udata {
        CommonHeader;
        uint8_t tag;

        int len;
        uint64_t metatable;

        union {
            char data[1];
            char align[1];
        };
    };

    struct TValue {
        union {
            uint64_t gcobject;
            void* p;
            double n;
            int b;
            float v[2];
        } value;

        int extra[1];
        int tt;
    };

    struct Proto {
        CommonHeader;

        TValue* k;       
        uint32_t* code;   
        Proto** p;   
        uint8_t* lineinfo;     
        int* abslineinfo;      
        uint64_t locvars;
        uint64_t upvalues;
        uint64_t source;

        uint64_t debugname;
        uint8_t* debuginsn;

        int64_t gclist;

        int sizecode;
        int sizep;
        int sizelocvars;
        int sizeupvalues;
        int sizek;
        int sizelineinfo;
        int linegaplog2;
        int linedefined;
        int bytecodeid;

        uint8_t nups;
        uint8_t numparams;
        uint8_t is_vararg;
        uint8_t maxstacksize;
    };

    struct lua_Debug {
        const char* name;
        const char* what;
        const char* source;
        const char* short_src;
        int linedefined;
        int currentline;
        unsigned char nupvals;
        unsigned char nparams;
        char isvararg;
        void* userdata;

        char ssbuf[256];
    };

    struct Closure {
        CommonHeader;

        uint8_t isC;
        uint8_t nupvalues;
        uint8_t stacksize;
        uint8_t preload;

        uint64_t gclist;
        uint64_t env;

        union {
            struct {
                uint64_t f;
                uint64_t cont;
                const char* debugname;
                TValue upvals[1];
            } c;

            struct {
                uint64_t p;
                TValue uprefs[1];
            } l;
        };
    };
}

namespace scheduler {
    struct job {
        void** vtable;
        char padding[0x90]; //0x10
        std::string job_name; // 0x18
    };

    std::vector<job*> scheduler_jobs;
}

std::string spoofed_hwid = "";
const char* session_file = "roblox_session";

bool deserialize_dumpscripts = false;
bool deserialize_printscripts = false;
bool prevent_server_teleports = false;

__int128 global_identity = 8;
uint64_t roblox_thread = 0;
uint64_t deserialize_thread = 0;
uint64_t scripts_env = 0;
uint64_t exploit_env = 0;
bool whitelisted = false;
int thread_valid = 0;
int thread_type = 0;
long aslr_slide = 0;

bool teleport_event = false;
std::vector<uint64_t> game_script_dir;
std::vector<std::string> teleport_script_queue;
std::unordered_map<std::string, uint64_t> game_script_map;
std::unordered_map<uint64_t, roblox_structs::Closure*> safe_newcclosure_map;

uint64_t apply_aslr(uint64_t address) {
    return address + aslr_slide;
}

uint64_t aslr_bypass(uint64_t address) {
    return address - aslr_slide;
}

uint64_t spawn_address = 0x1008d5428; //Spawn function requires -> spawn
uint64_t error_address = 0x102b5362a; //spawn function requires
uint64_t print_address = 0x100e61a47; //Current identity is %d
uint64_t getstate_address = 0x100958a5c; //startScript re-entrancy, used in newthread argument!
uint64_t newthread_address = 0x102425ce5; //Unable to create a new thread for %s
uint64_t deserialize_address = 0x102447762; //bytecode version mismatch -> deserialize
uint64_t newlclosure_address = 0x10242fc24; //Deserialize, case 6:
uint64_t setfield_address = 0x1024274a8; //ipairs -> second call
uint64_t pseudo2addr_address = 0x1024283c2; //index2addr -> 2nd condition
uint64_t pushcclosure_address = 0x102426cd5; //ipairs-> second last call
uint64_t pushlstring_address = 0x102426ace; //ipairs -> 4th call
uint64_t pushvalue_address = 0x102425ff0; //ipairs -> first call
uint64_t pcall_address = 0x102429773; //"ipairs" -> luab_pcally
uint64_t insert_address = 0x102425e79; //luab_pcallcont -> under pushboolean
uint64_t next_address = 0x102427bbe; //pairs -> cont func -> lua_next(arg1, 1) == 0
uint64_t getfield_address = 0x102426ef0; //_LOADED (third call ipairs) -> call below
uint64_t settop_address = 0x102425db8; //_LOADED (lua_settop(rl, -2))
uint64_t createtable_address = 0x102427179; //findtable("_LOADED") ->luaL_findtable -> lua_settop & lua_createtable(rl, 0, rbx_1)
uint64_t getmetatable_address = 0x1024272d6; //__metatable -> 3rd xref -> lua_pushnil(L) -> (getmetatable(rl, 1) == 0)
uint64_t checkany_address = 0x10242895c; //__metatable -> lua_pushnil(L) -> lua_checkany(rl, 1)
uint64_t rawseti_address = 0x1024276cc; //wrong number of arguments to 'insert' -> lua_rawseti(rl, 1, pos)
uint64_t getnum_address = 0x10243aaff; //get length of, inside big thing (1 arg)
uint64_t pushnumber_address = 0x102426a4e; //base out of range -> end of func -> lua_pushnumber(rl, zmm0[0])
uint64_t getinfo_address = 0x10242e18f; //"no function environment for" getinfo(arg1, arg2, &data_0, arg4) -> "invalid level"
uint64_t visitgco_address = 0x1024346f2; // "mainthread" (mainthread(arg1, arg2, sub_2))
uint64_t teleport_address = 0x10135a766; //"The previous teleport is in proc"
uint64_t private_address = 0x102b46c38; //"join-private-game" -> placeId -> rbx_private(d8, 'placeID', placeid)
uint64_t appendbool_address = 0x102b46c90; //"isTeleport"
uint64_t context_address = 0x102773d00; // RobloxEngine -> weird text -> that -> function it's in lol
uint64_t getidentity_address = 0x102773f80; // context -> 2nd xref -> 0 args
uint64_t setmetatable_address = 0x10242777f; //cannot change a protected metatable -> above -> settop(rl, 2) setmetatable(rl, 1)
uint64_t check_allowed_address = 0x101177308; //"HttpRequest.Url is not trusted" -> function check -> call inside function
uint64_t newudata_address = 0x102427e47; //"nil or boolean" -> newuserdatatagged
uint64_t rawgeti_address = 0x1024270e5; //"invalid value (%s) at index %d in table for \'concat\'" -> first call in function
uint64_t fireclickdetector_addr = 0x1010002b6; //"MaxActivationDistance" -> first call -> 3rd xref
uint64_t taskscheduler_address = 0x1044b2cb8; //SchedulerRate (gettaskscheduler() + 0x38) -> retval from else statement.
uint64_t tolstring_address = 0x1024264fc; //'__tostring' must return a string -> end of func -> called with -1
uint64_t fmtcurl_address = 0x102843e74; // "%s%s=%s"

uint64_t deserialize_exit = 0x0; //0x5641
uint64_t teleport_exit = 0x0; //0x5641

uint64_t concat_address = 0x10007d634; //initiateTeleportToPlace
uint64_t join_address = 0x10008bccf; //Delaying request by [NOT NEEDED]
uint64_t gettable_address = 0x10239ebce; //getfield -> 5 argument function call
uint64_t resume_address = 0x101dae046;  //"cannot resume dead coroutine" -> function xref #1 is in -> xref -> resume(uint64_t rl, uint64_t from, int nargs) 
//uint64_t newproto_address = 0x101a24926; //Deserialize where the offsets are used
//uint64_t getthread_address = 0x101a69f98; //startScript re-entrancy
//uint64_t namecall_address = 0x1000348d2; // "$namecall" -> namecall

uint64_t concat_exit = 0x10007d63a; //0x5641
uint64_t join_body = 0x10008bcd5; //0x5641
//uint64_t getglobal_hook_addr = 0x1019fd086;
//uint64_t getglobal_exit_addr = 0x1019fd08b;

typedef const char*(*tolstring_t)(uint64_t rl, int idx, size_t* size);
tolstring_t* rbx_tolstring2 = (tolstring_t*)&tolstring_address;

typedef uint64_t(*setmetatable_t)(uint64_t rl, int idx);
setmetatable_t* rbx_setmetatable = (setmetatable_t*)&setmetatable_address;

typedef uint64_t(*resume_t)(uint64_t rl, uint64_t from, int nargs);
resume_t* rbx_resume = (resume_t*)&resume_address;

typedef uint64_t(*getinfo_t)(uint64_t rl, int level, const char* what, roblox_structs::lua_Debug* ar);
getinfo_t* rbx_getinfo = (getinfo_t*)&getinfo_address;

typedef void(*pushnumber_t)(uint64_t rl, double number);
pushnumber_t* rbx_pushnumber = (pushnumber_t*)&pushnumber_address;

typedef uint64_t(*newuserdata_t)(uint64_t rl, size_t size, int tag);
newuserdata_t* rbx_newudata = (newuserdata_t*)&newudata_address;

typedef void(*fireclick_t)(uint64_t cd, uint64_t plr, float dist);
fireclick_t* rbx_fireclick = (fireclick_t*)&fireclickdetector_addr;

typedef int(*getnum_t)(uint64_t table);
getnum_t* rbx_getnum = (getnum_t*)&getnum_address;

typedef int(*next_t)(uint64_t rl, int idx);
next_t* rbx_next = (next_t*)&next_address;

typedef uint64_t(* getstate_t)(uint64_t sc, int* type, const int64_t* arg3);
getstate_t* rbx_getstate = (getstate_t*)&getstate_address;

typedef void(*rawseti_t)(uint64_t rl, int table_idx, int idx);
rawseti_t* rbx_rawseti = (rawseti_t*)&rawseti_address;

typedef int(*rawgeti_t)(uint64_t rl, int table_idx, int idx);
rawgeti_t* rbx_rawgeti = (rawgeti_t*)&rawgeti_address;

typedef uint64_t(* createtable_t)(uint64_t rl, int narr, int nrec);
createtable_t* rbx_createtable = (createtable_t*)&createtable_address;

typedef void(* insert_t)(uint64_t rl, int idx);
insert_t* rbx_insert = (insert_t*)&insert_address;

typedef void(* print2_t)(int type, const char* text, ...);
print2_t rbx_print2;

typedef void(* print_t)(int type, const char* text, ...);
print_t* rbx_print = (print_t*)&print_address;

typedef int64_t(* deserialize_t)(uint64_t rl, const char* source, const char* bytecode, int len, int env);
deserialize_t* rbx_deserialize = (deserialize_t*)&deserialize_address;

typedef int64_t(* spawn_t)(uint64_t rl);
spawn_t* rbx_spawn = (spawn_t*)&spawn_address;

typedef int64_t(* settop_t)(uint64_t rl, int size);
settop_t* rbx_settop = (settop_t*)&settop_address;

typedef void(* setfield_t)(uint64_t rl, int idx, const char* key);
setfield_t* rbx_setfield = (setfield_t*)&setfield_address;

typedef void(* pushcclosure_t)(uint64_t rl, int(*)(uint64_t), const char* debugname, int nup, uint64_t cont);
pushcclosure_t* rbx_pushcclosure = (pushcclosure_t*)&pushcclosure_address;

typedef void(* pushlstring_t)(uint64_t rl, const char* string, int64_t len);
pushlstring_t* rbx_pushlstring = (pushlstring_t*)&pushlstring_address;

typedef int64_t(* error_t)(const char* str, ...);
error_t* rbx_error = (error_t*)&error_address;

typedef uint64_t(* newthread_t)(uint64_t rl);
newthread_t* rbx_newthread = (newthread_t*)&newthread_address;

typedef void*(* pushvalue_t)(uint64_t rl, int idx);
pushvalue_t* rbx_pushvalue = (pushvalue_t*)&pushvalue_address;

typedef uint64_t(* getfield_t)(uint64_t rl, int idx, const char* name);
getfield_t* rbx_getfield = (getfield_t*)&getfield_address;

typedef uint64_t(* getmetatable_t)(uint64_t rl, int idx);
getmetatable_t* rbx_getmetatable = (getmetatable_t*)&getmetatable_address;

typedef void(* checkany_t)(uint64_t rl, int args);
checkany_t* rbx_checkany = (checkany_t*)&checkany_address;

typedef uint64_t(* pseudo2addr_t)(uint64_t rl, int idx);
pseudo2addr_t* rbx_pseudo2addr = (pseudo2addr_t*)&pseudo2addr_address;

typedef void(* call_t)(uint64_t rl, uint64_t func, int type);
call_t* rbx_call = (call_t*)&pcall_address;

typedef int(* pcall_t)(uint64_t rl);
pcall_t* rbx_pcall = (pcall_t*)&pcall_address;

typedef roblox_structs::Closure*(*newlclosure_t)(uint64_t rl, int nelems, uint64_t env, uint64_t proto);
newlclosure_t* rbx_newlclosure = (newlclosure_t*)&newlclosure_address;

typedef int64_t(*visitgco_t)(uint64_t rl, void* ctx, void* func);
visitgco_t* rbx_visitgco = (visitgco_t*)&visitgco_address;

typedef uint64_t(* gettable_t)(uint64_t rl, uint64_t arg2, uint64_t key, roblox_structs::TValue* val, uint64_t arg5);
gettable_t* rbx_gettable = (gettable_t*)&gettable_address;

//typedef uint64_t(* getthread_t)(int* type, int num);
//getthread_t* rbx_getthread = (getthread_t*)&getthread_address;

//typedef uint64_t(* newproto_t)(uint64_t rl);
//newproto_t* rbx_newproto = (newproto_t*)&newproto_address;

std::string skidded_gen_random(const int len) {
    static const char alphanum[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
    std::string tmp_s;
    tmp_s.reserve(len);

    for (int i = 0; i < len; ++i) {
        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
    }
    
    return tmp_s;
}

namespace settings {
    struct setting_obj_t {
        std::string key;
        std::string value;
    };

    std::unordered_map<std::string, bool> bool_settings {
        { "autoExecute", "true" },
        { "httpTraffic", "true" },
        { "placeRestrictions", "true" },
        { "settingsControl", "true" },
        { "executeInstances", "false" },
        { "autoInject", "false" }
    };

    bool get_boolean(std::string name) {
        return bool_settings[name];
    }

    void add_boolean(std::string key, std::string val) {
        bool_settings[key] = val == "false" ? false : true;
    }

    void handle_setting(std::string key, std::string value) {
        if (key == "serverTeleports") {
            prevent_server_teleports = value == "false" ? true : false;
            return;
        }

        if (key == "dumpScripts") {
            deserialize_dumpscripts = value == "false" ? false : true;
            return;
        }

        if (key == "logHttp") {
            deserialize_printscripts = value == "false" ? false : true;
            return;
        }

        if (key == "autoInject") {
            if (value == "true") {
                *(double*)(*(uint64_t*)taskscheduler_address + 0x138) = 1 / 400.0;
                return;
            }

            *(double*)(*(uint64_t*)taskscheduler_address + 0x138) = 1 / 60.0;
            return;
        }

        /*
        if (key == "multiInstance") {
            if (value == "true") {
                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "Drawing_Check");
                (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "Drawing");
                return;
            }

            rbx_pushnil(roblox_thread);
            (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "Drawing");
            return;
        } */

        if (key == "executeInstances" && value == "true") {
            spoofed_hwid = skidded_gen_random(37);
        }

        add_boolean(key, value);
    }
}

void rbx_register(uint64_t rl, int(* function)(uint64_t), const char* name) {
    (*rbx_pushcclosure)(rl, function, "Abyss", 0, 0);
    (*rbx_setfield)(rl, LUA_GLOBALSINDEX, name);
}

void rbx_pushstring(uint64_t rl, const std::string& str) {
    (*rbx_pushlstring)(rl, str.c_str(), str.size());
}

void serialize_proto(roblox_structs::Proto* proto, uint64_t newproto) {
    mach_vm_protect(mach_task_self(), newproto, 0x88, FALSE, VM_PROT_ALL);

    *(uint64_t*)(newproto + 0x8) = (uint64_t)proto->k + (newproto + 0x8);
    *(int*)(newproto + 0x60) = proto->sizek;
    *(uint64_t*)(newproto + 0x20) = (uint64_t)proto->p - (newproto + 0x20);
    *(int*)(newproto + 0x78) = proto->sizep;

    *(uint64_t*)(newproto + 0x30) = (uint64_t)proto->code ^ (newproto + 0x30);
    *(int*)(newproto + 0x64) = proto->sizecode;
    *(int*)(newproto + 0x70) = proto->sizeupvalues;
    *(uint8_t*)(newproto + 0x87) = proto->nups;
    *(uint64_t*)(newproto + 0x38) = (uint64_t)proto->upvalues - (newproto + 0x38);
    
    *(uint8_t*)(newproto + 0x86) = proto->maxstacksize;
    *(int*)(newproto + 0x7C) = proto->sizelineinfo;
    *(int*)(newproto + 0x68) = proto->linegaplog2;
    *(uint64_t*)(newproto + 0x10) = (newproto + 0x10) - (uint64_t)proto->lineinfo;
    *(uint64_t*)(newproto + 0x18) = (newproto + 0x18) + (uint64_t)proto->abslineinfo;

    *(int*)(newproto + 0x6C) = proto->sizelocvars;
    *(uint64_t*)(newproto + 0x40) = proto->locvars ^ (newproto + 0x40);
}

roblox_structs::Proto* deserialize_proto(uint64_t proto) {
    auto deserialized_proto = new roblox_structs::Proto;

    deserialized_proto->k = (roblox_structs::TValue*)(*(uint64_t*)(proto + 0x8) - (proto + 0x8));
    deserialized_proto->sizek = *(int*)(proto + 0x60);
    deserialized_proto->p = (roblox_structs::Proto**)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
    deserialized_proto->sizep = *(int*)(proto + 0x78);
    deserialized_proto->code = (uint32_t*)(*(uint64_t*)(proto + 0x30) ^ (proto + 0x30));
    deserialized_proto->sizecode = *(int*)(proto + 0x64);
    deserialized_proto->sizeupvalues = *(int*)(proto + 0x70);
    deserialized_proto->nups = *(uint8_t*)(proto + 0x87);
    deserialized_proto->upvalues = *(uint64_t*)(proto + 0x38) + (proto + 0x38);
    deserialized_proto->maxstacksize = *(uint8_t*)(proto + 0x86);
    deserialized_proto->sizelineinfo = *(int*)(proto + 0x7C);
    deserialized_proto->linegaplog2 = *(int*)(proto + 0x68);
    deserialized_proto->lineinfo = (uint8_t*)((proto + 0x10) - *(uint64_t*)(proto + 0x10));
    deserialized_proto->abslineinfo = (int*)(*(uint64_t*)(proto + 0x18) - (proto + 0x18));
    deserialized_proto->sizelocvars = *(int*)(proto + 0x6C);
    deserialized_proto->locvars = *(uint64_t*)(proto + 0x40) ^ (proto + 0x40);

    return deserialized_proto;
}

uint64_t filter_ptr_encryption(uint64_t ptr, ENC_TYPE type, bool enc_ptr = false) {
    uint64_t enc_data = *(uint64_t*)ptr;
    
    switch (type) {
        case ENC_ADD:
            return enc_ptr ? enc_data - ptr : enc_data + ptr;
        case ENC_XOR:
            return enc_data ^ ptr;
        case ENC_SUBPTR:
            return enc_ptr ? enc_data + ptr : enc_data - ptr;
        case ENC_SUBVAL:
            return enc_ptr ? ptr - enc_data : ptr - enc_data;
        default:
            return enc_data;
    }
}

uint64_t rbx_index2addr(uint64_t rl, int idx) {
    if (idx > 0) {
        return *(uint64_t*)(rl + offsets::state_base) + (idx - 1) * 0x10;
    } else if (idx > LUA_REGISTRYINDEX) {
        return *(uint64_t*)(rl + offsets::state_top) + idx * 0x10;
    } else {
        return (*rbx_pseudo2addr)(rl, idx);
    }
}

double rbx_tonumber(uint64_t rl, int idx) {
    auto value = (roblox_structs::TValue*)rbx_index2addr(rl, idx);
    return value->value.n;
}

int rbx_tointeger(uint64_t rl, int idx, int none) {
    return static_cast<int>(rbx_tonumber(rl, idx));
}

uint64_t rbx_touserdata(uint64_t rl, int idx) {
    auto udata = (roblox_structs::Udata*)(*(uint64_t*)rbx_index2addr(rl, idx));
    return (uint64_t)&udata->data;
}

void lua_ref(uint64_t rl) {
    (*rbx_pushvalue)(rl, LUA_REGISTRYINDEX);
    auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    int tableidx = (*rbx_getnum)(tval->value.gcobject) + 1;

    (*rbx_pushvalue)(rl, -2);
    (*rbx_rawseti)(rl, -2, tableidx);
    rbx_pop(rl, 1);
}

__int128* rbx_getidentity(uint64_t rl) {
    return (__int128*)(*(uint64_t*)(rl + 0x78) + 0x30);
}

bool ptr_is_valid(mach_vm_address_t address, vm_prot_t needs_access) {
    mach_vm_size_t size = 0;
    mach_port_t object_name;

    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;
    kern_return_t ret = mach_vm_region(mach_task_self(), &address, &size, VM_REGION_BASIC_INFO_64, (vm_region_info_t)&info, &count, &object_name);

    if (ret != KERN_SUCCESS) return false;
    return (info.protection & needs_access) == needs_access;
}

void new_context_hook() {
    mach_vm_protect(mach_task_self(), context_address, 2, FALSE, VM_PROT_ALL);
    uint8_t new_bytes[2] = { 0xC2, 0x10 };
    memcpy((void*)context_address, new_bytes, 2);
    mach_vm_protect(mach_task_self(), context_address, 2, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
}

const char* rbx_tolstring(uint64_t rl, int idx, size_t* size) {
    return (*rbx_tolstring2)(rl, idx, size);
    
    /*
    auto val = (roblox_structs::TValue*)rbx_index2addr(rl, idx);
    const char* sval = (const char*)(val->value.gcobject + 0x18);
    if (size) { *size = strlen(sval); }
    return sval; */
}

void multi_service() {
    while (true) {
        sem_unlink("/RobloxPlayerUniq");
        usleep(200000);
    }
}

bool print_pointer_stub(uint64_t ptr, int indentation) {
    if (indentation > 5) {
        return false;
    }

    std::string indent = "";
    for (int i = 0; i < indentation; i++) {
        indent.append("  ");
    }

    auto cl = (roblox_structs::Closure*)ptr;
    if (cl->tt == LUA_TFUNCTION) {
        if (!cl->isC) {
            std::cout << indent << "[Abyss] Closure 0x" << ptr << "\n";
            //uint64_t proto = (uint64_t)&cl->l.p + cl->l.p;
            //uint64_t debugname = (proto + 0x48) ^ *(uint64_t*)(proto + 0x48);
            //if (debugname) {
            //    const char* fname = (const char*)(debugname + 0x18);
            //    std::cout << indent << "Name: " << fname << "\n";
            //} else {
            //    std::cout << indent << "Name: Unknown\n";
            //}
            
            return true;
        }
    }

    bool positive_result = false;
    for (int i = 0; i < 64; i += 8) {
        uint64_t current_ptr = *(uint64_t*)(ptr + i);
        if (ptr_is_valid(current_ptr, VM_PROT_DEFAULT)) {
            if (print_pointer_stub(current_ptr, indentation + 1)) {
                std::cout << indent << "-> 0x" << ptr << " + 0x" << i << "\n";
                positive_result = true;
            }
        }
    }

    return positive_result;
}

void scan_pointer(uint64_t ptr) {
    std::cout << "[Abyss] Beginning Pointer Scan...\n";
    print_pointer_stub(ptr, 0);
}

uint64_t rbx_getstacktop(uint64_t rl) {
    return *(uint64_t*)(rl + offsets::state_top);
}

void rbx_incrementtop(uint64_t rl) {
    *(uint64_t*)(rl + offsets::state_top) += 0x10;
}

void rbx_decrementtop(uint64_t rl) {
    *(uint64_t*)(rl + offsets::state_top) -= 0x10;
}

void rbx_setsvalue(uint64_t address, uint64_t tvalue) {
    memcpy((void*)address, (void*)tvalue, 0x10);
}

void rbx_setidentity(uint64_t rl, __int128 identity) {
    *rbx_getidentity(rl) = identity;
}

#define LUA_YIELD 1
int rbx_yield(uint64_t rl, int nresults) {
    *(uint64_t*)(rl + offsets::state_base) = *(uint64_t*)(rl + offsets::state_top) - (0x10 * nresults);
    *(int8_t*)(rl + 3) = LUA_YIELD;
    return -1;
}

int rbx_gettop(uint64_t rl) {
    return static_cast<int>((rbx_getstacktop(rl) - rbx_index2addr(rl, 1)) / 16);
}

void rbx_pushboolean(uint64_t rl, bool value) {
    auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
    top->tt = LUA_TBOOLEAN;
    top->value.b = value;

    rbx_incrementtop(rl);
}

int rbx_gettype(uint64_t rl, int idx) {
    if (idx > 0) {
        return *(int*)(*(uint64_t*)(rl + offsets::state_base) + 0xC + (idx - 1) * 0x10);
    } else {
        return *(int*)(*(uint64_t*)(rl + offsets::state_top) + idx * 0x10 + 0xC);
    }
}

/*
int rbx_getinfo(uint64_t rl, const char* what, uint64_t func = 0, int level = 0) {
    roblox_structs::Closure* cl;
    if (func) {
        cl = (roblox_structs::Closure*)func;
    } else {
        if (level < 0) {
            auto fval = (roblox_structs::TValue*)(rbx_getstacktop(rl) - level * 0x10);
            cl = (roblox_structs::Closure*)fval->value.gcobject;            
        } else {
            uint64_t ci = *(uint64_t*)(rl + 0x8);
            ci -= level * 0x28;
            cl = *(roblox_structs::Closure**)(ci + 0x8);
        }
    }

    std::cout << "[Abyss] Successfully got closure: 0x" << (uint64_t)cl << "\n";
    return 0;
}

*/

void rbx_pushnil(uint64_t rl) {
    **(uint64_t**)(rl + offsets::state_top) = 0;
    *(int*)(*(uint64_t*)(rl + offsets::state_top) + 0xC) = LUA_TNIL;
    *(uint64_t*)(rl + offsets::state_top) += 0x10;
}

void skiddedReplaceAll(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
}

void sanitiseFileInput(std::string& ref) {
    skiddedReplaceAll(ref, "../", "");
    skiddedReplaceAll(ref, "..\\", "");
    skiddedReplaceAll(ref, "\\", "/");
}

uint64_t filter_globals(uint64_t rl) {
    (*rbx_pushvalue)(rl, LUA_GLOBALSINDEX);
    auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    uint64_t new_gt = (*rbx_createtable)(rl, 0, (*rbx_getnum)(tval->value.gcobject));
    uint64_t old_gt = tval->value.gcobject;
    (*rbx_insert)(rl, -2);

    rbx_pushnil(rl);
    while ((*rbx_next)(rl, -2)) {
        const char* key = rbx_tolstring(rl, -2, nullptr);
        if (!key) { rbx_pop(rl, 1); continue; }

        auto value = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        (*rbx_setfield)(rl, -4, key);
    }

    for (int i = 0; i < 0x100; i++) {
        if (*(uint64_t*)(rl + i) == old_gt) {
            *(uint64_t*)(rl + i) = new_gt;
            std::cout << "[Abyss] Updated Global Table at [0x" << i << "]\n";
            offsets::state_env = i;
            break;
        }
    }

    exploit_env = new_gt;
    (*rbx_createtable)(rl, 0, 0);
    (*rbx_setfield)(rl, -3, "_G");

    rbx_pop(rl, 2);
    return old_gt;
}

bool rbx_isnil(uint64_t rl, int idx) {
    return rbx_gettype(rl, idx) == LUA_TNIL;
}

void rbx_assert(uint64_t rl, bool result, std::string name, int type) {
    if (rbx_isnil(rl, -1) || rbx_gettype(rl, -1) != type) {
        (*rbx_error)(std::string("Invalid value for " + name).c_str(), 0);
    }
}

void rbx_setreadonly(uint64_t rl, int idx, bool readonly) {
    uint64_t table = *(uint64_t*)rbx_index2addr(rl, idx);
    *(int8_t*)(table + offsets::table::isreadonly_offset) = readonly;
}

void rbx_registerlib(uint64_t rl, std::string libname, std::unordered_map<std::string, int(*)(uint64_t)> functions) {
    (*rbx_getfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    if (rbx_isnil(rl, -1)) {
        rbx_pop(rl, 1);
        (*rbx_createtable)(rl, 0, functions.size());
        for (auto pair : functions) {
            (*rbx_pushcclosure)(rl, pair.second, "Abyss", 0, 0);
            (*rbx_setfield)(rl, -2, pair.first.c_str());
        }

        (*rbx_setfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    } else {
        auto old_lib = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        uint64_t new_lib = (*rbx_createtable)(rl, 0, (*rbx_getnum)(old_lib->value.gcobject) + functions.size());
        (*rbx_insert)(rl, -2);

        rbx_pushnil(rl);
        while ((*rbx_next)(rl, -2)) {
            const char* key = rbx_tolstring(rl, -2, nullptr);
            (*rbx_setfield)(rl, -4, key);
        }

        rbx_pop(rl, 1);
        for (auto pair : functions) {
            (*rbx_pushcclosure)(rl, pair.second, "Abyss", 0, 0);
            (*rbx_setfield)(rl, -2, pair.first.c_str());
        }

        (*rbx_setfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    }
}

std::string fetch_fingerprint() {
    uuid_t hwid_uuid; char hwid_str[37]; SHA1 checksum;
    struct timespec timeout{ NULL, NULL };
    gethostuuid((unsigned char*)&hwid_uuid, &timeout);
    uuid_unparse(hwid_uuid, hwid_str);
    checksum.update(std::string(hwid_str));
    return checksum.final();
}

/*
void exec_log(std::string data) {
    CURL* curl = curl_easy_init();
    curl_easy_setopt(curl, CURLOPT_URL, "http://203.219.222.96:8993/");
    struct curl_slist* curl_headers = curl_slist_append(NULL, std::string("Authentication: " + fetch_fingerprint()).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, curl_headers);
    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());
    curl_easy_perform(curl);
    curl_easy_cleanup(curl);
}

void log_exec(std::string data) {
    std::thread(exec_log, data).detach();
}
*/

bool execute_script(uint64_t rl, std::string script) {
    std::string script_bytecode = Luau::compile(script);

    if ((*rbx_deserialize)(rl, "=Script Abyss.Thread", script_bytecode.c_str(), script_bytecode.size(), 0) != 0) {
        (*rbx_print)(3, rbx_tolstring(rl, -1, nullptr));
        (*rbx_settop)(rl, 0);
        return false;
    }

    (*rbx_spawn)(rl);
    (*rbx_settop)(rl, 0);
    return true;
}

namespace LuauBytecode {
    enum LuauOpcode
    {
        // NOP: noop
        LOP_NOP,

        // BREAK: debugger break
        LOP_BREAK,

        // LOADNIL: sets register to nil
        // A: target register
        LOP_LOADNIL,

        // LOADB: sets register to boolean and jumps to a given short offset (used to compile comparison results into a boolean)
        // A: target register
        // B: value (0/1)
        // C: jump offset
        LOP_LOADB,

        // LOADN: sets register to a number literal
        // A: target register
        // D: value (-32768..32767)
        LOP_LOADN,

        // LOADK: sets register to an entry from the constant table from the proto (number/string)
        // A: target register
        // D: constant table index (0..32767)
        LOP_LOADK,

        // MOVE: move (copy) value from one register to another
        // A: target register
        // B: source register
        LOP_MOVE,

        // GETGLOBAL: load value from global table using constant string as a key
        // A: target register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_GETGLOBAL,

        // SETGLOBAL: set value in global table using constant string as a key
        // A: source register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_SETGLOBAL,

        // GETUPVAL: load upvalue from the upvalue table for the current function
        // A: target register
        // B: upvalue index (0..255)
        LOP_GETUPVAL,

        // SETUPVAL: store value into the upvalue table for the current function
        // A: target register
        // B: upvalue index (0..255)
        LOP_SETUPVAL,

        // CLOSEUPVALS: close (migrate to heap) all upvalues that were captured for registers >= target
        // A: target register
        LOP_CLOSEUPVALS,

        // GETIMPORT: load imported global table global from the constant table
        // A: target register
        // D: constant table index (0..32767); we assume that imports are loaded into the constant table
        // AUX: 3 10-bit indices of constant strings that, combined, constitute an import path; length of the path is set by the top 2 bits (1,2,3)
        LOP_GETIMPORT,

        // GETTABLE: load value from table into target register using key from register
        // A: target register
        // B: table register
        // C: index register
        LOP_GETTABLE,

        // SETTABLE: store source register into table using key from register
        // A: source register
        // B: table register
        // C: index register
        LOP_SETTABLE,

        // GETTABLEKS: load value from table into target register using constant string as a key
        // A: target register
        // B: table register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_GETTABLEKS,

        // SETTABLEKS: store source register into table using constant string as a key
        // A: source register
        // B: table register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_SETTABLEKS,

        // GETTABLEN: load value from table into target register using small integer index as a key
        // A: target register
        // B: table register
        // C: index-1 (index is 1..256)
        LOP_GETTABLEN,

        // SETTABLEN: store source register into table using small integer index as a key
        // A: source register
        // B: table register
        // C: index-1 (index is 1..256)
        LOP_SETTABLEN,

        // NEWCLOSURE: create closure from a child proto; followed by a CAPTURE instruction for each upvalue
        // A: target register
        // D: child proto index (0..32767)
        LOP_NEWCLOSURE,

        // NAMECALL: prepare to call specified method by name by loading function from source register using constant index into target register and copying source register into target register + 1
        // A: target register
        // B: source register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        // Note that this instruction must be followed directly by CALL; it prepares the arguments
        // This instruction is roughly equivalent to GETTABLEKS + MOVE pair, but we need a special instruction to support custom __namecall metamethod
        LOP_NAMECALL,

        // CALL: call specified function
        // A: register where the function object lives, followed by arguments; results are placed starting from the same register
        // B: argument count + 1, or 0 to preserve all arguments up to top (MULTRET)
        // C: result count + 1, or 0 to preserve all values and adjust top (MULTRET)
        LOP_CALL,

        // RETURN: returns specified values from the function
        // A: register where the returned values start
        // B: number of returned values + 1, or 0 to return all values up to top (MULTRET)
        LOP_RETURN,

        // JUMP: jumps to target offset
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMP,

        // JUMPBACK: jumps to target offset; this is equivalent to JUMP but is used as a safepoint to be able to interrupt while/repeat loops
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPBACK,

        // JUMPIF: jumps to target offset if register is not nil/false
        // A: source register
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPIF,

        // JUMPIFNOT: jumps to target offset if register is nil/false
        // A: source register
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPIFNOT,

        // JUMPIFEQ, JUMPIFLE, JUMPIFLT, JUMPIFNOTEQ, JUMPIFNOTLE, JUMPIFNOTLT: jumps to target offset if the comparison is true (or false, for NOT variants)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: source register 2
        LOP_JUMPIFEQ,
        LOP_JUMPIFLE,
        LOP_JUMPIFLT,
        LOP_JUMPIFNOTEQ,
        LOP_JUMPIFNOTLE,
        LOP_JUMPIFNOTLT,

        // ADD, SUB, MUL, DIV, MOD, POW: compute arithmetic operation between two source registers and put the result into target register
        // A: target register
        // B: source register 1
        // C: source register 2
        LOP_ADD,
        LOP_SUB,
        LOP_MUL,
        LOP_DIV,
        LOP_MOD,
        LOP_POW,

        // ADDK, SUBK, MULK, DIVK, MODK, POWK: compute arithmetic operation between the source register and a constant and put the result into target register
        // A: target register
        // B: source register
        // C: constant table index (0..255)
        LOP_ADDK,
        LOP_SUBK,
        LOP_MULK,
        LOP_DIVK,
        LOP_MODK,
        LOP_POWK,

        // AND, OR: perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register
        // A: target register
        // B: source register 1
        // C: source register 2
        LOP_AND,
        LOP_OR,

        // ANDK, ORK: perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register
        // A: target register
        // B: source register
        // C: constant table index (0..255)
        LOP_ANDK,
        LOP_ORK,

        // CONCAT: concatenate all strings between B and C (inclusive) and put the result into A
        // A: target register
        // B: source register start
        // C: source register end
        LOP_CONCAT,

        // NOT, MINUS, LENGTH: compute unary operation for source register and put the result into target register
        // A: target register
        // B: source register
        LOP_NOT,
        LOP_MINUS,
        LOP_LENGTH,

        // NEWTABLE: create table in target register
        // A: target register
        // B: table size, stored as 0 for v=0 and ceil(log2(v))+1 for v!=0
        // AUX: array size
        LOP_NEWTABLE,

        // DUPTABLE: duplicate table using the constant table template to target register
        // A: target register
        // D: constant table index (0..32767)
        LOP_DUPTABLE,

        // SETLIST: set a list of values to table in target register
        // A: target register
        // B: source register start
        // C: value count + 1, or 0 to use all values up to top (MULTRET)
        // AUX: table index to start from
        LOP_SETLIST,

        // FORNPREP: prepare a numeric for loop, jump over the loop if first iteration doesn't need to run
        // A: target register; numeric for loops assume a register layout [limit, step, index, variable]
        // D: jump offset (-32768..32767)
        // limit/step are immutable, index isn't visible to user code since it's copied into variable
        LOP_FORNPREP,

        // FORNLOOP: adjust loop variables for one iteration, jump back to the loop header if loop needs to continue
        // A: target register; see FORNPREP for register layout
        // D: jump offset (-32768..32767)
        LOP_FORNLOOP,

        // FORGLOOP: adjust loop variables for one iteration of a generic for loop, jump back to the loop header if loop needs to continue
        // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
        // D: jump offset (-32768..32767)
        // AUX: variable count (1..255) in the low 8 bits, high bit indicates whether to use ipairs-style traversal in the fast path
        // loop variables are adjusted by calling generator(state, index) and expecting it to return a tuple that's copied to the user variables
        // the first variable is then copied into index; generator/state are immutable, index isn't visible to user code
        LOP_FORGLOOP,

        // FORGPREP_INEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_inext, and jump to FORGLOOP
        // A: target register (see FORGLOOP for register layout)
        LOP_FORGPREP_INEXT,

        // removed in v3
        LOP_DEP_FORGLOOP_INEXT,

        // FORGPREP_NEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_next, and jump to FORGLOOP
        // A: target register (see FORGLOOP for register layout)
        LOP_FORGPREP_NEXT,

        // removed in v3
        LOP_DEP_FORGLOOP_NEXT,

        // GETVARARGS: copy variables into the target register from vararg storage for current function
        // A: target register
        // B: variable count + 1, or 0 to copy all variables and adjust top (MULTRET)
        LOP_GETVARARGS,

        // DUPCLOSURE: create closure from a pre-created function object (reusing it unless environments diverge)
        // A: target register
        // D: constant table index (0..32767)
        LOP_DUPCLOSURE,

        // PREPVARARGS: prepare stack for variadic functions so that GETVARARGS works correctly
        // A: number of fixed arguments
        LOP_PREPVARARGS,

        // LOADKX: sets register to an entry from the constant table from the proto (number/string)
        // A: target register
        // AUX: constant table index
        LOP_LOADKX,

        // JUMPX: jumps to the target offset; like JUMPBACK, supports interruption
        // E: jump offset (-2^23..2^23; 0 means "next instruction" aka "don't jump")
        LOP_JUMPX,

        // FASTCALL: perform a fast call of a built-in function
        // A: builtin function id (see LuauBuiltinFunction)
        // C: jump offset to get to following CALL
        // FASTCALL is followed by one of (GETIMPORT, MOVE, GETUPVAL) instructions and by CALL instruction
        // This is necessary so that if FASTCALL can't perform the call inline, it can continue normal execution
        // If FASTCALL *can* perform the call, it jumps over the instructions *and* over the next CALL
        // Note that FASTCALL will read the actual call arguments, such as argument/result registers and counts, from the CALL instruction
        LOP_FASTCALL,

        // COVERAGE: update coverage information stored in the instruction
        // E: hit count for the instruction (0..2^23-1)
        // The hit count is incremented by VM every time the instruction is executed, and saturates at 2^23-1
        LOP_COVERAGE,

        // CAPTURE: capture a local or an upvalue as an upvalue into a newly created closure; only valid after NEWCLOSURE
        // A: capture type, see LuauCaptureType
        // B: source register (for VAL/REF) or upvalue index (for UPVAL/UPREF)
        LOP_CAPTURE,

        // removed in v3
        LOP_DEP_JUMPIFEQK,
        LOP_DEP_JUMPIFNOTEQK,

        // FASTCALL1: perform a fast call of a built-in function using 1 register argument
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        LOP_FASTCALL1,

        // FASTCALL2: perform a fast call of a built-in function using 2 register arguments
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        // AUX: source register 2 in least-significant byte
        LOP_FASTCALL2,

        // FASTCALL2K: perform a fast call of a built-in function using 1 register argument and 1 constant argument
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        // AUX: constant index
        LOP_FASTCALL2K,

        // FORGPREP: prepare loop variables for a generic for loop, jump to the loop backedge unconditionally
        // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
        // D: jump offset (-32768..32767)
        LOP_FORGPREP,

        // JUMPXEQKNIL, JUMPXEQKB: jumps to target offset if the comparison with constant is true (or false, see AUX)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit
        LOP_JUMPXEQKNIL,
        LOP_JUMPXEQKB,

        // JUMPXEQKN, JUMPXEQKS: jumps to target offset if the comparison with constant is true (or false, see AUX)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit
        LOP_JUMPXEQKN,
        LOP_JUMPXEQKS,

        // Enum entry for number of opcodes, not a valid opcode by itself!
        LOP__COUNT
    };
}

namespace hook {
    char deserialize_bytes[12] = "\x55\x48\x89\xe5\x41\x57\xe9\x11\x11\x11\x11";
    char create_job_bytes[12] = "\x55\x48\x89\xe5\x41\x57\xe9\x11\x11\x11\x11";
    char connect_bytes[12] = "\x55\x48\x89\xe5\x41\x56\xe9\x11\x11\x11\x11";
    size_t hook_len = 11;

    #define LUAU_INSN_A(insn) (((insn) >> 8) & 0xff)
    #define LUAU_INSN_B(insn) (((insn) >> 16) & 0xff)
    #define LUAU_INSN_C(insn) (((insn) >> 24) & 0xff)
    #define LUAU_INSN_OP(insn) ((insn) & 0xff)
    void disassemblefunc(uint64_t closure) {
        uint64_t proto = (closure + 0x18) + *(uint64_t*)(closure + 0x18);
        uint32_t* pc = (uint32_t*)((proto + 0x40) ^ *(uint64_t*)(proto + 0x40));
        int sizecode = *(int*)(proto + 0x80);

        while (true) {
            uint8_t op = LUAU_INSN_OP(*pc++) * 203;
            switch (op) {
                case LuauBytecode::LOP_RETURN:
                    std::cout << "[Abyss] End of bytecode.\n";
                    return;
                case LuauBytecode::LOP_NOP:
                    printf("nop\n");
                    break;
                case LuauBytecode::LOP_LOADNIL: {
                    uint32_t insn = *pc++;
                    printf("loadnil r%d\n", LUAU_INSN_A(insn));
                    break;
                }
                default:
                    std::cout << "Unknown Opcode.\n";
            }
            pc++;
        }
    }

    void dumpconstants(uint64_t closure, bool print = true) {
        auto lclosure = (roblox_structs::Closure*)closure;
        uint64_t proto = lclosure->l.p - (uint64_t)&lclosure->l.p;
        roblox_structs::Proto eproto;
        eproto.k = (roblox_structs::TValue*)(*(uint64_t*)(proto + 0x18) - (proto + 0x18));
        eproto.sizek = *(int*)(proto + 0x68);

        auto lproto = &eproto;
        int sizek = lproto->sizek;
        //std::cout << "[Abyss] Successfully Deserialized Proto, Found " << std::dec << sizek << std::hex << " Constants.\n";
        auto constants = lproto->k;
        for (int i = 0; i < sizek; i++) {
            auto constant = constants[i];
            int type = constant.tt;
            //std::cout << "DATA: 0x" << type << "\n";

            switch (type) {
                case LUA_TNUMBER:
                    //if (print) std::cout << "[Abyss] Number: " << constant.value.n << "\n";
                    break;
                case LUA_TSTRING:
                    //if (print) std::cout << "[Abyss] Constant: " << (const char*)(constant.value.gcobject + 0x18) << "\n";
                    {
                        const char* str = (const char*)(constant.value.gcobject + 0x18);
                        if (std::string(str) == "t33eugde") {
                            std::cout << "\n[Abyss] SUCCESSFULLY TRACKED DOWN STRING: " << str << "\nYA\nYA\n\n";
                        }

                        break;
                    }
                case LUA_TFUNCTION: {
                    auto closure = (roblox_structs::Closure*)constant.value.gcobject;
                    bool isC = closure->isC;

                    if (!isC) {
                        //if (print) std::cout << "[Abyss] Closure Begin.\n";
                        dumpconstants((uint64_t)closure, print);
                        //if (print) std::cout << "[Abyss] Closure End.\n";
                    }

                    break;
                }
                default:
                    //if (print) std::cout << "[Abyss] Unknown Constant: " << std::dec << type << std::hex << "\n";
                    break;
            }
        }
    }

    std::string dumped_script_name = "";
    std::string dumped_script = "";

    void dump_script_closure_save() {
        std::string workspace_path = std::string(getenv("HOME")) + "/Documents/";

        std::string script = dumped_script;
        std::string name = dumped_script_name;
        if (!std::filesystem::exists(workspace_path + "Macsploit Dumped")) {
            std::filesystem::create_directory(workspace_path + "Macsploit Dumped");
        }

        std::ofstream file(workspace_path + "Macsploit Dumped/" + name + ".lua");
        file << script;
        file.close();

        std::cout << "[Abyss] Script Saved.\n";
    }

    void dump_script_closure_stub(uint64_t rl, uint64_t proto, int indentation);
    void dump_script_proto(uint64_t rl, uint64_t proto, int indentation) {
        //uint64_t debugname = *(uint64_t*)(proto + 0x48) - (proto + 0x48);
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        //uint8_t numparams = *(uint8_t*)(proto + 0x9e);
        //bool is_vararg = *(uint8_t*)(proto + 0x9d);
        auto cl = (*rbx_newlclosure)(rl, 0, 0, proto);
        auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
        top->value.gcobject = (uint64_t)cl;
        top->tt = LUA_TFUNCTION;
        rbx_incrementtop(rl);

        roblox_structs::lua_Debug debug;
        (*rbx_getinfo)(rl, -1, "flnsu", &debug);
        rbx_pop(rl, 2);

        uint8_t numparams = debug.nparams;
        bool is_vararg = debug.isvararg;

        std::string args = "";
        if (numparams > 0 && numparams < 100) {
            for (int i = 1; i < numparams; i++) {
                args.append("arg" + std::to_string(i) + ", ");
            }

            args.append("arg" + std::to_string(numparams));
            if (is_vararg) {
                args.append(", ");
            }
        }

        char buffer[1024];
        if (is_vararg) {
            args.append("...");
        }

        const char* name = "";
        if (debug.name && strcmp(debug.name, ""))
            name = debug.name;

        snprintf(buffer, 1024, "function %s(%s)\n", name, args.c_str());
        dumped_script.append(indent + std::string(buffer));
        dump_script_closure_stub(rl, proto, indentation + 1);
        dumped_script.append(indent + "end\n\n");
    }

    void dump_script_constant(uint64_t rl, roblox_structs::TValue* constant, int indentation) {
        int type = constant->tt;
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        switch (type) {
            case LUA_TTABLE:
            {
                dumped_script.append(indent + "Table {\n");
                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)constant);
                rbx_incrementtop(rl);
                rbx_pushnil(rl);

                int values = 0;
                while ((*rbx_next)(rl, -2)) {
                    if (values) {
                        dumped_script.append("\n");
                    }

                    (*rbx_pushvalue)(rl, -2);
                    dump_script_constant(rl, (roblox_structs::TValue*)rbx_index2addr(rl, -1), indentation + 1);
                    dump_script_constant(rl, (roblox_structs::TValue*)rbx_index2addr(rl, -2), indentation + 1);

                    values++;
                    rbx_pop(rl, 2);
                }

                dumped_script.append(indent + "}\n");
                rbx_pop(rl, 1);
                break;
            }
            case LUA_TFUNCTION:
            {
                auto closure = (roblox_structs::Closure*)constant->value.gcobject;   
                if (!closure->isC) {
                    uint64_t proto = filter_ptr_encryption((uint64_t)&closure->l.p, PROTO_ENC); // PROTO_DEC((uint64_t)&closure->l.p);
                    dump_script_proto(rl, proto, indentation);
                }

                break;
            }
            case LUA_TSTRING:
            {
                uint64_t ts = constant->value.gcobject;
                const char* str = (const char*)(ts + 0x18);
                dumped_script.append(indent + std::string(str) + "\n");
                break;
            }
            case LUA_TNUMBER:
            {
                double num = constant->value.n;
                dumped_script.append(indent + std::to_string(num) + "\n");
                break;
            }
            case LUA_TUSERDATA:
            {
                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)constant);
                rbx_incrementtop(rl);

                (*rbx_getmetatable)(rl, -1);
                (*rbx_getfield)(rl, -1, "__type");
                auto __type = (roblox_structs::TValue*)rbx_index2addr(rl, -1);

                if (__type->tt == LUA_TSTRING) {
                    const char* typestr = rbx_tolstring(rl, -1, nullptr);
                    dumped_script.append(indent + std::string(typestr) + "\n");
                } else {
                    dumped_script.append(indent + "nil\n");
                }

                rbx_pop(rl, 3);
                break;
            }
        }
    }

    void dump_script_closure_stub(uint64_t rl, uint64_t proto, int indentation) {
        int sizep = *(int*)(proto + offsets::proto::sizep);
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        if (sizep) {
            uint64_t* protos = (uint64_t*)filter_ptr_encryption(proto + offsets::proto::protos, PROTOS_ENC); //(uint64_t*)(*(uint64_t*)(proto + 0x20) ^ (proto + 0x20));
            for (int i = 0; i < sizep; i++) {
                uint64_t subproto = protos[i];
                dump_script_proto(rl, subproto, indentation);
            }
        }

        int sizek = *(int*)(proto + offsets::proto::sizek);
        auto constants = (roblox_structs::TValue*)(filter_ptr_encryption((proto + offsets::proto::constants), CONSTANT_ENC));
        for (int i = 0; i < sizek; i++) {
            auto constant = constants[i];
            dump_script_constant(rl, &constant, indentation);
        }
    }

    void dump_script_closure(uint64_t rl, std::string source) {
        auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto closure = (roblox_structs::Closure*)tval->value.gcobject;
        uint64_t proto = filter_ptr_encryption((uint64_t)&closure->l.p, PROTO_ENC); // PROTO_DEC((uint64_t)&closure->l.p);

        dumped_script_name = source;
        dumped_script = "-- " + source + "\n\n";

        dump_script_closure_stub(rl, proto, 0);
        std::thread(dump_script_closure_save).detach();
    }

    bool runex(const char* source, uint64_t rl) {
        std::string scriptname(source + 1);
        if (scriptname.find("CmdrClient.Shared.Dispatcher") != std::string::npos) {
            std::cout << "[Abyss] Cmdr Dispatcher Script Executed.\n";
            auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
            auto closure = (roblox_structs::Closure*)tval->value.gcobject;
            uint64_t proto = (uint64_t)&closure->l.p + closure->l.p;

            int sizep = *(int*)(proto + 0x80);
            uint64_t* protos = (uint64_t*)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
            for (int i = 0; i < sizep; i++) {
                uint64_t subproto = protos[i];
                uint64_t debugname = (subproto + 0x48) ^ *(uint64_t*)(subproto + 0x48);

                if (!debugname) continue;
                const char* name = (const char*)(debugname + 0x18);
                if (!strcmp(name, "RunHooks")) {
                    std::cout << "[Abyss] Target Function Identified!\n";
                    /*
                    std::string hook_bytecode = Luau::compile(R"(
                        return function(...)
                            print("C++/Lua Hook Has Been Executed.")
                            return
                        end
                    )");

                    (*rbx_deserialize)(rl, "=Script Abyss.Hook", hook_bytecode.c_str(), hook_bytecode.size(), 0);
                    auto cval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
                    auto cl = (roblox_structs::Closure*)cval->value.gcobject;
                    uint64_t newproto = (uint64_t)&closure->l.p + closure->l.p;
                    std::cout << "[Abyss] Function proto: 0x" << newproto << "\n";
                    protos[i] = newproto;

                    rbx_pop(rl, 1); 
                    std::cout << "[Abyss] Updated Proto.\n"; */
                    auto newclosure = (*rbx_newlclosure)(roblox_thread, 0, 0, subproto);
                    std::cout << "Created NEWLCLOSURE\n";
                    auto topval = (roblox_structs::TValue*)rbx_getstacktop(roblox_thread);
                    topval->value.gcobject = (uint64_t)newclosure;
                    topval->tt = LUA_TFUNCTION;
                    rbx_incrementtop(roblox_thread);

                    std::cout << "[Abyss] Saved Original Proto.\n";
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "ghookedfunction");
                    std::cout << "[Abyss] Target Proto Saved.\n";
                    return true;
                }
            }
        }

        std::cout << "Function Return.\n";
        return false;
    }

    bool process_scripts = true;
    bool success1 = false;
    int scripts_executed = 0;
    int64_t deserialize_hook(uint64_t rl, const char* source, const char* bytecode, int len, int env) {
        scripts_executed++;
        int64_t result = (*rbx_deserialize)(rl, source, bytecode, len, env);
        if (deserialize_dumpscripts && !result) {
            std::cout << "[Abyss] Dumping: " << (source + 1) << "\n";
            dump_script_closure(rl, source + 1);
        }

        if (!result && deserialize_thread && source) {
            auto thread = *(roblox_structs::GCObject*)deserialize_thread;
            if (thread.tt != LUA_TTHREAD) return result;

            auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
            auto cl = (roblox_structs::Closure*)tval->value.gcobject;

            if (process_scripts) {
                (*rbx_getfield)(deserialize_thread, LUA_GLOBALSINDEX, "script_buffer");
                auto tvalx = (roblox_structs::TValue*)rbx_index2addr(deserialize_thread, -1);

                if (tvalx->tt == LUA_TTABLE) {
                    const char* script_path = (const char*)(source + 1);
                    int tableidxx = (*rbx_getnum)(tvalx->value.gcobject) + 1;
                    (*rbx_createtable)(deserialize_thread, 3, 0);

                    rbx_pushstring(deserialize_thread, std::string(script_path));
                    (*rbx_rawseti)(deserialize_thread, -2, 1);

                    (*rbx_deserialize)(deserialize_thread, source, bytecode, len, env);
                    (*rbx_rawseti)(deserialize_thread, -2, 2);

                    (*rbx_pushlstring)(deserialize_thread, bytecode, len);
                    (*rbx_rawseti)(deserialize_thread, -2, 3);

                    (*rbx_rawseti)(deserialize_thread, -2, tableidxx);
                }

                rbx_pop(deserialize_thread, 1);
            }

            if (deserialize_printscripts) {
                uint64_t retn_address = (uint64_t)__builtin_return_address(0);
                std::cout << "[Load] " << (const char*)(source + 1) << "\n";
                std::cout << "[Load] Returning to 0x" << aslr_bypass(retn_address) << "\n";
            }

            //game_script_dir.push_back(filter_ptr_encryption((uint64_t)&cl->l.p, PROTO_ENC));
            //game_script_map[(source + 1)] = (uint64_t)cl;
        }

        return result;
    }

    /*
        std::cout << "[Abyss] " << source << "\n";
        auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto closure = (roblox_structs::Closure*)tval->value.gcobject;

        uint64_t proto = (uint64_t)&closure->l.p + closure->l.p;
        int sizelocvars = *(int*)(proto + 0x6C);
        if (!sizelocvars) {
            std::cout << "[Abyss] This script has no local variable information.\n";
        }

        for (int i = 0; i < sizelocvars; i++) {
            uint64_t locvar = *(uint64_t*)(proto + 0x30) + (0x18 * i);
            uint64_t ts = *(uint64_t*)locvar;
            std::cout << std::dec;

            std::cout << "[Abyss] Local Variable " << i << " Name: " << (const char*)(ts + 0x18) << "\n";
            std::cout << std::hex;
        }

        int sizeupvalues = *(int*)(proto + 0x70);
        if (!sizeupvalues) {
            std::cout << "[Abyss] This script has no upvalue information.\n";
        }

        uint64_t* upvalues = (uint64_t*)((proto + 0x10) + *(uint64_t*)(proto + 0x10));
        for (int i = 0; i < sizeupvalues; i++) {
            uint64_t upvalue = upvalues[i];
            std::cout << "[Abyss] Upvalue Name: " << (const char*)(upvalue + 0x18) << "\n";
        }

        int sizep = *(int*)(proto + 0x80);
        if (!sizep) {
            std::cout << "[Abyss] This script has no declared functions.\n";
        }

        uint64_t* protos = (uint64_t*)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
        for (int i = 0; i < sizep; i++) {
            uint64_t subproto = protos[i];
            uint64_t debugname = (subproto + 0x48) ^ *(uint64_t*)(subproto + 0x48);

            if (debugname) {
                uint8_t numparams = *(uint8_t*)(proto + 0x84);
                bool is_vararg = *(uint8_t*)(proto + 0x87);
                std::string args = "";

                if (numparams > 0) {
                    for (int i = 1; i < numparams; i++) {
                        args.append("arg" + std::to_string(i) + ", ");
                    }

                    args.append("arg" + std::to_string(numparams));
                    if (is_vararg) {
                        args.append(", ");
                    }
                }

                char buffer[1024];
                args.append("...");

                sprintf(buffer, "function %s(%s)\n\nend", (const char*)(debugname + 0x18), args.c_str());
                std::cout << "\n" << buffer << "\n";
            }
        }

    */

    typedef int(* teleport_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3);
    teleport_t rbx_teleport;

    int teleport_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3) {
        std::cout << "\n[Abyss] Game Initiated Teleport...\n";
        std::cout << "[Abyss] Return Address: " << aslr_bypass((uint64_t)__builtin_return_address(0)) << "\n\n";
        if (prevent_server_teleports) {
            return 0;
        }

        teleport_event = true;
        return (*rbx_teleport)(arg1, arg2, arg3);
    }

    std::unordered_map<std::string, bool> gettable_map;
    uint64_t gettable_hook(uint64_t rl, uint64_t t, roblox_structs::TValue* key, roblox_structs::TValue* val, uint64_t arg5) {
        if (key->tt == LUA_TSTRING && *rbx_getidentity(rl) == 8) {
            const char* gettable_key = (const char*)(key->value.gcobject + 0x18);
            int64_t res = (*rbx_gettable)(rl, t, (uint64_t)key, val, arg5);
            
            if (!gettable_map[gettable_key]) {
                std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
                gettable_map[gettable_key] = true;
                return res;
            }
            
            /*
            if (!strcmp(gettable_key, "TextBox") && val->tt == LUA_TFUNCTION) {
                std::cout << "\nAAA\n\n";
                std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
                int size = rbx_gettop(rl);
                uint64_t cl_addr;
                cl_addr = val->value.gcobject;
                auto cl = (roblox_structs::Closure*)cl_addr;
                uint64_t proto = filter_ptr_encryption((uint64_t)&cl->l.p, PROTO_ENC);
                uint64_t constant = (proto + offsets::proto::constants);
                uint64_t constants = filter_ptr_encryption(constant, CONSTANT_ENC);
                int size_constants = *(int*)(proto + offsets::proto::sizek);
                for (int i = 0; i < size_constants; i++) {
                    auto current_constant = *((roblox_structs::TValue*)constants + i);
                    if (current_constant.tt != LUA_TSTRING) continue;
                    const char* data = (const char*)(current_constant.value.gcobject + 0x18);
                    std::cout << "Dumped Constant: " << data << "\n";
                }

                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)val);
                rbx_incrementtop(rl);
                (*rbx_spawn)(rl);
                (*rbx_settop)(rl, size);
                return res;
            } */
/*
            if (!gettable_map[gettable_key]) {
                std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
                gettable_map[gettable_key] = true;
                return res;
            }
            */
            return res;
            /*
            for (int i = 0; i < rbx_gettop(rl); i++) {
                int idx = -1 - i;
                if (rbx_gettype(rl, idx) == LUA_TSTRING) {
                    std::cout << "[Constant] " << rbx_tolstring(rl, idx, nullptr) << "\n";
                }
            } */
        }

        return (*rbx_gettable)(rl, t, (uint64_t)key, val, arg5);
    }

    uint8_t gettable_bytes[11] = { 0x55, 0x48, 0x89, 0xE5, 0x41, 0x57, 0xE9, 0x0, 0x0, 0x0, 0x0 };
    void hook_gettable(void* hook_func) {
        uint64_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, 5, VM_FLAGS_ANYWHERE);
        memcpy((void*)tramp_addr, gettable_bytes, sizeof(gettable_bytes));

        int exit_rel_addr = (gettable_address + 0x6) - (tramp_addr + 11);
        *(int*)(tramp_addr + 7) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), tramp_addr, sizeof(gettable_bytes), FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        mach_vm_protect(mach_task_self(), gettable_address, 5, FALSE, VM_PROT_ALL);

        int hook_rel_addr = (uint64_t)hook_func - (gettable_address + 5);
        *(char*)gettable_address = 0xE9;
        *(int*)(gettable_address + 1) = hook_rel_addr;

        mach_vm_protect(mach_task_self(), gettable_address, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        *(uint64_t*)rbx_gettable = tramp_addr;
    }

    /*
    uint8_t getglobal_bytes[19] = { 0x52, 0x50, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x58, 0x4D, 0x8B, 0x44, 0x24, 0x18, 0xE9, 0x00, 0x00, 0x00, 0x00 };
    void hook_getglobal(void* hook_func) {
        uint64_t alloc_address;
        mach_vm_allocate(mach_task_self(), &alloc_address, sizeof(getglobal_bytes), VM_FLAGS_ANYWHERE);
        memcpy((void*)alloc_address, getglobal_bytes, sizeof(getglobal_bytes));

        int hook_rel_addr = (uint64_t)hook_func - (alloc_address + 7);
        *(int*)(alloc_address + 3) = hook_rel_addr;

        int exit_rel_addr = getglobal_exit_addr - (alloc_address + 19);
        *(int*)(alloc_address + 15) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), getglobal_hook_addr, 5, FALSE, VM_PROT_ALL);

        int tramp_rel_addr = alloc_address - (getglobal_hook_addr + 5);
        *(char*)getglobal_hook_addr = 0xE9;
        *(int*)(getglobal_hook_addr + 1) = tramp_rel_addr;

        mach_vm_protect(mach_task_self(), getglobal_hook_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }
    */

    typedef int64_t(*delay_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, double delay);
    delay_t rbx_delay;

    double new_delay = 0.0;
    int64_t delay_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3, double delay) {
        printf("\n[DELAY] Hook Step!\n");
        printf("[DELAY] Supposed Value: %4.2f\n", delay);
        printf("[DELAY] New Value: %4.2f\n\n", new_delay);
        return rbx_delay(arg1, arg2, arg3, new_delay);
    }
    
    typedef int64_t(*concat_t)(uint64_t arg1, uint64_t arg2);
    concat_t rbx_concat;

    void advanced_hook(uint64_t rl, int total, int last) {
        if ((*rbx_gettop)(rl) >= 40 && rbx_gettype(rl, 26) == LUA_TSTRING && rbx_gettype(rl, 27) == LUA_TSTRING) {
            std::string a1 = rbx_tolstring(rl, 26, nullptr);
            std::string a2 = rbx_tolstring(rl, 27, nullptr);
            std::string result = a1 + a2;

            std::cout << "[Collection] " << result << "\n";
            if (result == "Unkown") {
                rbx_pushstring(rl, "Fuck you lol, i, colrealpro, will never let you execute this script!");
                rbx_setsvalue(rbx_index2addr(rl, 26), rbx_index2addr(rl, -1));
                rbx_pop(rl, 1);
            }
        }

        //(*rbx_concat)(rl, total, last);
    }

    void concat_hook2(uint64_t rl, int total, int last) {
        std::cout << "\n[CONCAT] Hook Step!\n";
        int size = (*rbx_gettop)(rl);
        printf("Stack Size: %d\n", size);
        for (int i = 0; i < size; i++) {
            int index = i + 1;
            printf("%d ", index);
            if (rbx_gettype(rl, index) == LUA_TSTRING) {
                std::cout << "[STRING] " << rbx_tolstring(rl, index, nullptr) << "\n";
            } else if (rbx_gettype(rl, index) == LUA_TNUMBER) {
                auto value = (roblox_structs::TValue*)rbx_index2addr(rl, index);   
                std::cout << "[NUMBER] " << std::dec << value->value.n << std::hex << "\n";
            } else {
                printf("\n");
            }
        }

        std::cout << "\n";
        //(*rbx_concat)(rl, total, last);
    }

    void hook_delay() {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(join_body) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_delay = (delay_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t join_addr = apply_aslr(join_address);
        mach_vm_protect(mach_task_self(), join_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)delay_hook - (join_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)join_addr, jmp_bytes, 5);
        *(int*)(join_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), join_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    typedef int64_t(* connect_t)(uint64_t arg1, int64_t arg2, uint64_t arg3, int arg4);
    connect_t rbx_connect;

    typedef void(* command_t)(uint64_t args, std::string script);
    command_t rbx_command;

    uint64_t connect_address = 0x100f621f0;
    uint64_t connect_exit = 0x100f621f6;

    int64_t check_allowed_hook(uint64_t arg1, uint64_t arg2) {
        return settings::get_boolean("httpTraffic");
    }

    void command_hook(uint64_t args, std::string script) {
        std::cout << "Command hook executed!\n";
        std::cout << "Script: " << script << "\n";
        return rbx_command(args, script);
    }

    int64_t streaming_hook(uint64_t arg1, int64_t arg2, uint64_t arg3, int arg4) {
        std::cout << "[Abyss] Game Streaming Hook Actived!\n"; 
        uint64_t dm = ((uint64_t(*)(uint64_t))apply_aslr(0x101069970))(arg1);
        std::cout << "[Abyss] Game Streaming Enabled: " << (*(bool*)(dm + 0x639) ? "True" : "False") << "\n";

        std::cout << std::dec;
        std::cout << "Target Radius: " << *(int*)(dm + 0x63c) << "\n";
        std::cout << "Min Radius: " << *(int*)(dm + 0x640) << "\n";
        
        int render_distance = 1;
        //*(bool*)(dm + 0x639) = false;
        *(int*)(dm + 0x63c) = render_distance;
        *(int*)(dm + 0x640) = render_distance;

        std::cout << std::hex;
        std::cout << "[Abyss] Spoofed Game Streaming!\n";
        return rbx_connect(arg1, arg2, arg3, arg4);
    }

    int64_t connect_hook(uint64_t rl) {
        std::cout << "\n[Connect] Hooked Connect Function Stepped!\n";
        printf("[Connect] First Argument: 0x%llX\n", rl);

        
        int stacksize = (*rbx_gettop)(rl);
        std::cout << "[Connect] Gettop: 0x" << stacksize << "\n";

        auto udata = (roblox_structs::Udata*)(**(uint64_t**)(rl + offsets::state_base));
        uint64_t data = (uint64_t)&udata->data;
        int64_t* iptr = (int64_t*)data;
        std::string signalname = **(std::string**)(data + 0x28);
        std::cout << "[Connect] Name: " << signalname << "\n";
        std::cout << "[Connect] Unknown: 0x" << iptr[4] << "\n";
        std::cout << "[Connect] Identity: 0x" << static_cast<int>(*rbx_getidentity(rl)) << "\n";
        uint64_t interest = *(uint64_t*)(rl + 0x78);
        std::cout << "[Connect] Sus Pointer: 0x" << *(uint64_t*)(*(uint64_t*)(interest + 0x18) + 8) << "\n";
        printf("[Connect] Unknown Check: %d\n", *(int*)(data + 0x3c));
        ((int64_t(*)())apply_aslr(0x101ae121a))();
        uint64_t* fptr = *(uint64_t**)apply_aslr(0x103552ed8);
        printf("[Connect] fcheck2: 0x%llX\n", aslr_bypass(fptr[1]));
        sleep(1000);

        auto val = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto func = (roblox_structs::Closure*)(val->value.gcobject);
        std::cout << "[Connect] IsC: " << (func->isC ? "true" : "false") << "\n";
        uint64_t proto = func->l.p ^ (uint64_t)&func->l.p;
        uint64_t ts = *(uint64_t*)(proto + 0x20) + (proto + 0x20);
        const char* source = (const char*)(ts + 0x18);
        std::cout << "[Connect] Source: " << source << "\n";
        std::cout << "[Connect] Returning Function...\n\n";
        int64_t result = 0; //rbx_connect(rl, 0); 
        auto val2 = (roblox_structs::TValue*)rbx_index2addr(rl, 3);
        std::cout << "[Connect] Return TT: " << std::dec << val2->tt << std::hex << "\n";
        return result;
    }

    void hook_connect() {
        uint64_t connect_addr = apply_aslr(check_allowed_address);
        mach_vm_protect(mach_task_self(), connect_addr, 5, FALSE, VM_PROT_ALL);

        *(char*)connect_addr = 0xE9;
        *(int*)(connect_addr + 1) = (uint64_t)check_allowed_hook - (connect_addr + 5);

        mach_vm_protect(mach_task_self(), connect_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }

    void hook_teleports() {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(teleport_exit) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_teleport = (teleport_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(teleport_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)teleport_hook - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    typedef int(* namecall_t)(uint64_t rl);
    namecall_t rbx_namecall;

    typedef uint64_t(* fmtcurl_t)(uint64_t arg1, const char* arg2, const char* arg3, const char* arg4, const char* arg5);
    fmtcurl_t rbx_fmtcurl;

    char cookie[2048];
    bool prevent_change = false;
    char roblox_session[2048];
    uint64_t fmtcurl_hook(uint64_t arg1, const char* arg2, const char* arg3, const char* arg4, const char* arg5) {
        if (!strcmp("%s%s=%s", arg2) && (uint64_t)arg5 > 0x600000000000) {
            if (strstr(arg5, "DO-NOT-SHARE") != NULL) {
                arg5 = roblox_session;
            }
        }

        return rbx_fmtcurl(arg1, arg2, arg3, arg4, arg5);
    }

    /*
    int64_t pp_hook(const char* arg1, const char* arg2, const char* arg3, uint64_t arg4, char arg5) {
        std::cout << "\n[Abyss] Hook Activation:\nInstance: " << arg1 << "\nType: " << arg2 << "\nEvent: " << arg3 << "\n\n";
        return rbx_pp(arg1, arg2, arg3, arg4, arg5);
    }*/

    //typedef int64_t(* context_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5);
    typedef int64_t(* context_t)(uint64_t idk, const char* error_type, const char* name_of_thing);
    typedef int64_t(* new_context_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5);
    new_context_t rbx_new_context;
    context_t rbx_context;

    int64_t debug_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing, uint64_t more, uint64_t more2, uint64_t more3, uint64_t padding, uint64_t padding2, uint64_t more4, uint64_t more5) {
        std::cout << "mor1: 0x" << more << "\n";
        std::cout << "mor2: 0x" << more2 << "\n";
        std::cout << "mor3: 0x" << more3 << "\n";
        std::cout << "mor4: 0x" << more4 << "\n";
        std::cout << "mor5: 0x" << more5 << "\n";
        std::cout << "mr4 0x" << rbx_gettop(more) << "\n";
        std::cout << "Hook: " << name_of_thing << " with " << error_type << " error.\n";
        std::cout << "\n[Abyss] Context Triggered, error_type: " << error_type << " name_of_thing: " << name_of_thing << ".\n";
        std::cout << "[Abyss] Return Address: " << aslr_bypass((uint64_t)__builtin_return_address(0)) << "\n\n";
        return 0x10;
    }

    int64_t new_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing) {
        return 0x10;
    }

            /*
        if (!name_of_thing || (strcmp(name_of_thing, "settings") || identity > 7) && (strcmp(name_of_thing, "RobloxLocked") && 
            !(idk == 0x8001 && !strcmp(name_of_thing, "CreatePlugin") && !strcmp(error_type, "call")))) {
            //__tlv_bootstrap
            std::cout << "[Abyss] Context hook called for " << error_type << "!\n[Abyss] Context: 0x" << idk << " Arg: " << name_of_thing << " Identity: 0x" << identity << "\n -> Bypassing...\n";
            return 0x10;


                int64_t old_context_hook(uint64_t identity_flag, const char* error_type, const char* name_of_thing) {
        //100936a45(getidentity(), arg1)
        //uint64_t addr = apply_aslr(0x104551e88);
        //(uint64_t(*)(int*, uint64_t))(apply_aslr(0x100936a45))(global_identity, roblox_thread);
        uint64_t addr = ((uint64_t(*)())apply_aslr(0x10275157c))();
        int identity = *reinterpret_cast<int*>(addr);
        //uint64_t smth = *reinterpret_cast<int64_t*>(addr + 0x18);
        // *reinterpret_cast<int64_t*>(addr + 0x18) = 0x0;
        //std::cout << "Something: 0x" << ((uint64_t(*)(uint64_t))apply_aslr(0x10105001c))(smth) << "\n";
        //std::cout << "0x" << *(uint64_t*)smth << "\n";

        return 0x10; // rbx_context(0x8001, error_type, name_of_thing);

                //100936a45(getidentity(), arg1)
        //uint64_t addr = apply_aslr(0x104551e88);
        //(uint64_t(*)(int*, uint64_t))(apply_aslr(0x100936a45))(global_identity, roblox_thread);
        uint64_t addr = ((uint64_t(*)())apply_aslr(0x10275157c))();
        int identity = *reinterpret_cast<int*>(addr);
        //uint64_t smth = *reinterpret_cast<int64_t*>(addr + 0x18);
        //std::cout << "Something: 0x" << ((uint64_t(*)(uint64_t))apply_aslr(0x10105001c))(smth) << "\n";
        //std::cout << "0x" << *(uint64_t*)smth << "\n";
    }
        }*/

    int64_t old_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing) {
        uint64_t addr = ((uint64_t(*)())apply_aslr(getidentity_address))();
        int identity = *reinterpret_cast<int*>(addr);

        if (!name_of_thing || identity < 7 && (!strcmp(name_of_thing, "settings") || !strcmp(name_of_thing, "RobloxLocked") || !strcmp(name_of_thing, "CreatePlugin") || !strcmp(name_of_thing, "CoreGui"))) {
            return rbx_context(idk, error_type, name_of_thing);
        }

        return 0x10;
    }

    int64_t context_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5) {
        uint64_t rdi_1 = *(uint64_t*)(arg1 + 0x20);
        uint64_t rax_4 = (rdi_1 & arg3);

        const char* str = "";
        if ((uint64_t)arg4 != 0) {
            str = arg4;
        }

        if (!strcmp(str, "access")) {
            std::cout << "top: 0x" << rbx_gettop(arg1) << "\n";
            std::cout << "\n[Abyss] Context hook called for " << str << "!\n[Abyss] Context: 0x" << rax_4 << " Arg: 0x" << arg3 << " -> Bypassing...\n\n";
        }

        if (rax_4 != arg3) {
            return rax_4;
        }

        //return rbx_context(arg1, arg2, arg3, arg4, arg5);
        return 0;
    }

    char create_job_bytes_2[17] = "\x55\x48\x89\xe5\x48\x81\xec\xd0\x00\x00\x00\xe9\x11\x11\x11\x11";
    uint64_t hook_address_2(uint64_t n_addr, void* func) {
        uint64_t namecall_address = n_addr;
        int tramp_len = sizeof(create_job_bytes_2) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes_2, tramp_len);

        int rel_addr = apply_aslr(namecall_address + 11) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(namecall_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        return tramp_addr;
    }

    uint64_t hook_address(uint64_t n_addr, void* func) {
        uint64_t namecall_address = n_addr;
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(namecall_address + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(namecall_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        return tramp_addr;
    }

    void safe_hook_context(context_t func) {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(context_address  + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_context = (context_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(context_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    void hook_context() {
        uint64_t context_addr = apply_aslr(context_address);
        mach_vm_protect(mach_task_self(), context_addr, 5, FALSE, VM_PROT_ALL);

        *(char*)context_addr = 0xE9;
        *(int*)(context_addr + 1) = (uint64_t)debug_context_hook - (context_addr + 5);

        mach_vm_protect(mach_task_self(), context_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }

    void hook_deserialize(deserialize_t hook_func) {
        mach_vm_address_t tramp_addr;
        deserialize_exit = apply_aslr(deserialize_exit);
        mach_vm_allocate(mach_task_self(), &tramp_addr, hook_len, VM_FLAGS_ANYWHERE);
        memcpy((void*)tramp_addr, deserialize_bytes, hook_len);

        int exit_rel_addr = deserialize_exit - (tramp_addr + hook_len);
        *(int*)(tramp_addr + (hook_len - 4)) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), deserialize_address, 5, FALSE, VM_PROT_ALL);
        mach_vm_protect(mach_task_self(), tramp_addr, hook_len, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);

        *(char*)deserialize_address = 0xE9;
        uint64_t hook_rel_addr = (uint64_t)hook_func - (deserialize_address + 5);
        *(int*)(deserialize_address + 1) = hook_rel_addr;

        mach_vm_protect(mach_task_self(), deserialize_address, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
        *(uint64_t*)rbx_deserialize = tramp_addr;
    }

    typedef uint64_t(* private_t)(uint64_t d8, const char* arg2, uint64_t arg3);
    bool debug_private = false;
    private_t rbx_private;

    uint64_t private_hook(uint64_t json, const char* name, int64_t num) {
        uint64_t retn_address = (uint64_t)__builtin_return_address(0);
        if (!strcmp(name, "placeId") && *(int*)retn_address != 0x24548b49 && settings::get_boolean("placeRestrictions")) {
            if (debug_private) { std::cout << "\n[Abyss] Private Hook Activation Record!\n[Abyss] Successfully Modified Value.\n\n"; }
            auto append_bool = reinterpret_cast<uint64_t(*)(uint64_t, const char*, int)>(apply_aslr(appendbool_address));
            append_bool(json, "isTeleport", 1);
            return rbx_private(json, name, num);
        }

        if (debug_private) { std::cout << "[Abyss] Returning Hook for " << name << "...\n"; }
        return rbx_private(json, name, num);
    }

    void hook_private() {
        int tramp_len = sizeof(connect_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, connect_bytes, tramp_len);

        int rel_addr = apply_aslr(private_address + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_private = (private_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(private_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)private_hook - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }
}

#endif //CLIENT_EXPLOIT_H
