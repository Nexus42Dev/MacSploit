//
// Created by Nexus Pancakes on 6/11/2022.
//

#ifndef CLIENT_EXPLOIT_H
#define CLIENT_EXPLOIT_H
#include <vector>
#include <string>
#include <unistd.h>
#include <fstream>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <Luau/Compiler.h>
#include <Luau/BytecodeBuilder.h>
#include <unordered_map>
#include <semaphore.h>
#include <curl/curl.h>
#include <uuid/uuid.h>

#define DEBUG_MODE

#include "security/obfuscator.hpp"
#include "discord-rpc/discord_rpc.h"
#include "sha1.hpp"

static void dylib_entry() __attribute__((constructor));

enum ENC_TYPE {
    ENC_ADD,
    ENC_XOR,
    ENC_SUBPTR,
    ENC_SUBVAL
};

#define LUA_REGISTRYINDEX (-10000)
#define LUA_ENVIRONINDEX (-10001)
#define LUA_GLOBALSINDEX (-10002)
#define lua_upvalueindex(i) (LUA_GLOBALSINDEX - (i))
#define rbx_pop(L, n) (*rbx_settop)(L, -(n)-1)

#define LUA_TBOOLEAN 1
#define LUA_TSTRING 5
#define LUA_TUSERDATA 7
#define LUA_TBUFFER 6
#define LUA_TTABLE 8
#define LUA_TNUMBER 2
#define LUA_TTHREAD 9
#define LUA_TVECTOR 4
#define LUA_TFUNCTION 10
#define LUA_TUPVAL 12
#define LUA_TNIL 0
#define LUA_TNONE -1

#define PROTO_ENC ENC_XOR
#define PROTOS_ENC ENC_SUBPTR
#define FUNCTION_ENC ENC_XOR
#define CONTINUE_ENC ENC_ADD
#define CONSTANT_ENC ENC_ADD
#define GLOBAL_ENC ENC_SUBPTR
#define CODE_ENC ENC_SUBPTR

#define PROTO_DEC(a) *(uint64_t*)a - a //"function":
#define PROTOS_DEC(a) *(uint64_t*)a - a //"protos"
#define FUNCTION_DEC(a) *(uint64_t*)a - a //ipairs -> pushcclosure
#define CONSTANT_DEC(a) *(uint64_t*)a + a //deserialize, third new array call
#define GLOBAL_DEC(a) *(uint64_t*)a + a //ipairs, newcclosure
#define CODE_DEC(a) *(uint64_t*)a + a //deserialize, first new array call

const char* anon = R"(⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣷⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⠛⠻⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣁⠀⠀⠀⠀⣀⣤⣶⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⠛⠉⠛⠶⠀⠀⢐⠿⠋⠀⢨⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢷⣿⣿⣶⠀⠀⠉⢶⣿⣿⠿⢿⣿⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣶⡶⠂⠀⣀⠀⢀⡄⠐⢲⡾⣻⣿⣿⣿⠇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣯⢿⡶⣶⣿⣟⣿⡶⠶⣿⢣⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⣾⣿⣿⣿⣧⠛⠒⠠⣤⣤⠶⠾⢣⣿⣿⣿⣿⣿⣤⣀⠀⠀⠀
⢀⣠⣤⣶⣶⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⢿⣿⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 [Abyss] Digital Software
    -> Developed by milo

)";

std::string current_version = "1.0";
std::string init_script = OBFUSCATE(R"(
getgenv().protect_cache = {}
getgenv().hooked_cache = {}

local fetch_setting = fetch_setting
getgenv().crypto = crypt

local wl = {
    connect = newcclosure(function(Url)
        assert(fetch_setting('debugLibrary'), "Websockets Disabled.")
        assert(Url, "Invalid argument #1 to WebSocket.Connect. Expected string, got ".. type(Url))
        OnMessage = Instance.new('BindableEvent')
        OnClose = Instance.new('BindableEvent')

        Socket = websocketconnect_c(Url, OnMessage, OnClose)
        game.Players.PlayerRemoving:Connect(function(leaving)
            if leaving == game.Players.LocalPlayer then
                if Socket and Socket.Connected then
                    Socket:Close(true)
                end
            end
        end)

        return Socket
    end)
}

getgenv()[fetch_setting('debugLibrary') and "WebSocket" or "_WebSocket"] = wl
getgenv().hookfunction = newcclosure(function(func, hook)
    assert(func, 'expected function for argument #1, got some bullshit.')
    assert(hook, 'expected function for argument #2, got some more bullshit.')
    table.insert(hooked_cache, func)

    if iscclosure(func) or iscclosure(hook) then
        table.insert(getreg(), hook)
        return swapfunction(func, newcclosure_s(hook))
    end

    return hookfunction_c(func, hook)
end)

getgenv().isfunctionhooked = newcclosure(function(func)
    return table.find(hooked_cache, func) ~= nil
end)

getgenv().hookfunc = hookfunction
getgenv().hookmetamethod = newcclosure(function(instance, metamethod, closure)
    local mt = getrawmetatable(instance)
    old_metaclosure = hookfunction(mt[metamethod], closure)
    return old_metaclosure
end)

getgenv().unsafehookmetamethod = newcclosure(function(instance, metamethod, closure)
    local mt = getrawmetatable(instance)
    setreadonly(mt, false)

    old_metaclosure = mt[metamethod]
    mt[metamethod] = closure

    setreadonly(mt, true)
    return old_metaclosure
end)

function reverse(myTable)
	if myTable and #myTable > 1 then
		local temp = nil
		for n = 1,math.floor(#myTable/2) do
			temp = myTable[n]
			myTable[n] = myTable[#myTable-(n-1)]
			myTable[#myTable-(n-1)] = temp
		end 
	end

    return myTable
end

getgenv().randomstring = function(length)
    local str = ""
    for _ = 1, length or 20 do
        local type = math.random(1,3)
        if type == 1 then
            str = str .. string.char(math.random(97,122)) -- Lowercase
        elseif type == 2 then
            str = str .. string.char(math.random(65,90)) -- Uppercase
        elseif type == 3 then
            str = str .. string.char(math.random(48,57)) -- Numbers
        end
    end
    return str
end

getgenv().shared = {}
getgenv().cache = game
debug.getfenv = getfenv
getgenv().randomString = randomstring
getgenv().clonetable = newcclosure(function(tbl)
    local clone = {}
    for i, v in tbl do
        clone[i] = v
    end

    return clone
end)

getgenv().sethiddenproperty = newcclosure(function(inst, name, val)
    console_print('Pretended to set a hidden property of '.. inst.Name.. ' xd: '.. name.. ' to '.. tostring(val))
end)

getgenv().getcallingscript = newcclosure(function(level)
    level = level and level + 1 or 1
    local func = setfenv(level, getfenv(level))
    return rawget(getfenv(func), "script")
end)

getgenv().quickLoad = newcclosure(function(url)
    return loadstring(game:HttpGet(url))()
end)

getgenv().getsenv = newcclosure(function(parameter)
    for i,v in pairs(debug.getregistry()) do
        if type(v) == "function" and islclosure(v) and getfenv(v).script == parameter then
            return getfenv(v)
        end
    end
end)

local script_env = Instance.new("LocalScript")
script_env.Name = randomstring()
getgenv().script = script_env

getgenv().rconsolename = function(name) console_print('-- '.. name.. ' --') end
getgenv().rconsolewarn = function(text) console_print('WARN: '.. text) end
getgenv().rconsoleerr = function(text) console_print('ERROR: '.. text) end
getgenv().rconsoleprint = console_print

getgenv().getthreadidentity = get_thread_identity
getgenv().setthreadidentity = setidentity
getgenv().set_fps_cap = setfpscap

getgenv().getinfo = debug.getinfo
getgenv().getconstants = debug.getconstants
getgenv().getproto = debug.getproto

getgenv().isourclosure = isexecutorclosure
getgenv().is_synapse_function = isexecutorclosure
getgenv().isexploitclosure = isexecutorclosure
getgenv().isexecutorfunction = isexecutorclosure
getgenv().isexploitfunction = isexecutorclosure
getgenv().isourfunction = isexecutorclosure
getgenv().isgameclosure = function(cl)
    return not isexecutorclosure(cl)
end

getgenv().newlclosure = function(cl)
    return function(...)
        return cl(...)
    end
end

getgenv().getinstances = function()
    local insts = {}
    for _, v in getreg() do
        if type(v) == 'table' then
            for _, s in pairs(v) do
                if typeof(s) == 'Instance' then
                    table.insert(insts, s)
                end
            end
        end
    end

    return insts
end

getgenv().getnilinstances = function()
    local insts = {}
    for _, v in getreg() do
        if type(v) == 'table' then
            for _, s in pairs(v) do
                if typeof(s) == 'Instance' and s.Parent == nil then
                    table.insert(insts, s)
                end
            end
        end
    end

    return insts
end

getgenv().firetouchinterest = newcclosure(function(part, transmitter, toggle)
    assert(typeof(part) == 'Instance' and part:IsA('BasePart'), "incorrect argument #1 to 'firetouchinterest', expected BasePart.")
    assert(typeof(part) == 'Instance' and transmitter:IsA('BasePart'), "incorrect argument #2 to 'firetouchinterest', expected BasePart.")
    return firetouchinterest_c(part, transmitter, toggle)
end)

getgenv().fireproximityprompt = function(Obj, Amount, Skip)
	assert(typeof(Obj) == "Instance", "invalid argument #1 to 'fireproximityprompt' (ProximityPrompt expected, got " .. type(Spoof) .. ") ")
	assert(Obj.ClassName == "ProximityPrompt", "invalid argument #1 to 'fireproximityprompt' (ProximityPrompt expected, got " .. type(Spoof) .. ") ")
    assert(type(Amount) == "number", "invalid argument #2 to 'fireproximityprompt' (number expected, got " .. type(Amount) .. ") ", 2)
	Amount = Amount or 1
    local PromptTime = Obj.HoldDuration
    if Skip then
        Obj.HoldDuration = 0
    end
    for i = 1, Amount do
        Obj:InputHoldBegin()
        if not Skip then
            wait(Obj.HoldDuration)
        end
        Obj:InputHoldEnd()
    end
    Obj.HoldDuration = PromptTime
end

getgenv().async_request = function(options)
    assert(fetch_setting('httpTraffic'), "HTTP Currently Disabled.")
    console_print(options.Url)

    if string.find(options.Url, 'webhooks') then
        console_print(options.Body)
    end

    rawset(options.Headers, 'User-Agent', nil)
	local Event = Instance.new("BindableEvent")
	local RequestInternal = game:GetService("HttpService").RequestInternal
	local Request = RequestInternal(game:GetService("HttpService"), options)
	
	local Response
	Request:Start(function(state, response)
		Response = response
		Event:Fire()
	end)
	
	Event.Event:Wait()
    console_print('Successful Request.')
    if string.find(options.Url, 'ink/tokenValid/') then
        console_print('work.ink bypass (milo).')
        Response.Body = '{"valid":true}'
    end

	return Response
end

local htp1 = newcclosure(function(options)
    assert(fetch_setting('httpTraffic'), "HTTP Currently Disabled.")
    if fetch_setting("resumeHandle") then
        return http_request_c(options)
    end

    if not options.Headers then
        rawset(options, 'Headers', {})
    end
    
    local fingerprint = gethwid()
    assert(options.Url, 'Failed to retrieve URL property.')
    rawset(options, 'Method', string.upper(options.Method or "Get"))
    rawset(options.Headers, 'Macsploit-Fingerprint', fingerprint)

    if fetch_setting("compatibilityMode") then
        rawset(options.Headers, 'Hydrogen-Fingerprint', fingerprint)
    end

    if options.Cookies then
        local cookies = ''
        for i, v in options.Cookies do
            cookies = cookies.. i.. '='.. v.. ';'
        end
        
        rawset(options.Headers, 'Cookie', cookies)
        rawset(options, 'Cookies', nil)
    end
    
    local Response = async_request(options)
    task.wait()
    
    Response.Cookies = {}
    if Response.Headers and Response.Headers['Cookie'] then
        for cookie in string.gmatch(Response.Headers['Cookie'], '([^;]+)') do
            local data = {}
            for str in string.gmatch(cookie, '([^=]+)') do
                table.insert(data, str)
            end
            
            Response.Cookies[Data[1]] = Data[2]
        end
    end
    
    return Response
end)

getgenv()[fetch_setting('httpTraffic') and "http_request" or "_http_request"] = htp1
getgenv().gethui = function()
  return game.CoreGui
end

getgenv().request = http_request
getgenv().http = {
    ['request'] = http_request
}

getgenv().getsignalfuncs = function(signal)
    local connection = signal:Connect(function() return end)
    local indexes = getallindexes(connection)
    local registry = getreg()
    local functions = {}
    
    for _, i in indexes do
        table.insert(functions, registry[i])
    end
    
    connection:Disconnect()
    return functions
end

getgenv().firesignal = function(signal, ...)
    local connections = getconnections(signal)
    for _, connection in connections do
        connection.Function(...)
    end
end

getgenv().getconnections = function(signal)
    local connection = signal:Connect(function() return end)
    local connections = getconnections_c(connection)
    connection:Disconnect()
    return connections
end

getgenv().fireclickdetector = function(clickdetector, distance)
    fireclickdetector_c(clickdetector, game.Players.LocalPlayer, distance)
end

getgenv().queueonteleport = queue_on_teleport
--getgenv().getscriptclosure = function(script)
--    return getscriptfromname(script:GetFullName())
--end

local htp2 = function(url, async)
    assert(fetch_setting('httpTraffic'), "HTTP Currently Disabled.")
    if fetch_setting("resumeHandle") then
        return httpget_c(url)
    end

    local fingerprint = gethwid()
    local Headers = {
        ['Macsploit-Fingerprint'] = fingerprint
    }

    if fetch_setting("compatibilityMode") then
        Headers['Hydrogen-Fingerprint'] = fingerprint
    end

    local Response = async_request({
        Url = url:gsub('\n', ''),
        Method = "GET",
        Headers = Headers
    }).Body

	task.wait()
	return Response
end

getgenv()[fetch_setting('httpTraffic') and "httpget_async" or "_httpget_async"] = htp2
getgenv().get_objects = function(self, ...)
    return { game:GetService("InsertService"):LoadLocalAsset(...) }
end

getgenv().protect_instance = newcclosure(function(inst)
    table.insert(protect_cache, inst)
end)

getgenv().unprotect_instance = newcclosure(function(inst)
    table.remove(protect_cache, table.find(protect_cache, inst))
end)

getgenv().syn = {
    ['protect_gui'] = protect_instance,
    ['unprotect_gui'] = unprotect_instance,
    ['queue_on_teleport'] = queue_on_teleport,
    ['request'] = http_request
}

getgenv().protectgui = protect_instance
getgenv().protect_gui = protect_instance
getgenv().unprotectgui = unprotect_instance
getgenv().unprotect_gui = unprotect_instance

local old_namecall
old_namecall = hookmetamethod(game, '__namecall', function(...)
    local self = ...
    local method = getnamecallmethod()

    if not checkcaller() then
        local results = { old_namecall(...) }
        if string.lower(method) == "findfirstchild" then
            if results[1] and table.find(protect_cache, results[1]) then
                results[1] = nil
            end
        end

        if string.lower(method) == "getdescendants" then
            if type(results[1]) == 'table' then
                for i, v in results[1] do
                    if table.find(protect_cache, v) then
                        table.remove(results[1], i)
                    end
                end
            end
        end

        if string.lower(method) == "getchildren" then
            if type(results[1]) == 'table' then
                for i, v in results[1] do
                    if table.find(protect_cache, v) then
                        table.remove(results[1], i)
                    end
                end
            end
        end

        return unpack(results)
    end

    if method == "HttpGet" or method == "HttpGetAsync" then
        local self, url = ...      
        return httpget_async(url)
    end

    if method == "GetObjects" then
        return get_objects(...)
    end

    return old_namecall(...)
end)

getgenv().httpget_async_index = function(self, ...)
    return httpget_async(...)
end

getgenv().get_objects_index = function(self, ...)
	return get_objects(self, ...)
end

local old_index
old_index = hookmetamethod(game, '__index', function(...)
    local self, idx = ...
    if not checkcaller() or self ~= game then
        local results = { old_index(...) }
        if results[1] and table.find(protect_cache, results[1]) then
            results[1] = nil
        end

        return unpack(results)
    end
    if idx == "HttpGet" or idx == "HttpGetAsync" then
        return httpget_async_index
    end

    if idx == "GetObjects" then
        return get_objects_index
    end

    if idx == "ClassName" then
        return old_index(...)
    end

    local success, value = pcall(function()
        local Service = game:GetService(idx)
        if Service and type(Service) ~= 'string' then
            return true
        end

        return false
    end)

    if not success or not value then
        return old_index(...)
    end

    return game:GetService(idx)
end)

local roblox_focused = false
game.Changed.Connect(game.UserInputService.WindowFocusReleased, function()
    roblox_focused = false
end)

game.Changed.Connect(game.UserInputService.WindowFocused, function()
    roblox_focused = true
end)

getgenv().isrbxactive = newcclosure(function()
    return roblox_focused
end)

oldRequire = require
getgenv().require = newcclosure(function(...)
    local script = ... -- JB Sensation Temp Fix
    pcall(function()
        if script == game.CoreGui.RobloxGui.Modules.InspectAndBuy.Components.Notification then
            oldRequire(game.CorePackages.Packages._Index.UIBlox.UIBlox).init()
        end
    end)

    identity = getidentity()
    setidentity(2)
    
    local success, result = pcall(oldRequire, ...)
    if not success then
        setidentity(3)
        result = oldRequire(...)
    end

    setidentity(identity)
    return result
end)

oldGameRequire = getrobloxenv().require
getrobloxenv().require = newcclosure(function(...)
    setidentity(2)
    local success, result = pcall(oldGameRequire, ...)
    if not success then
        setidentity(3)
        return oldGameRequire(...)
    end

    return result
end)

--[[
getgenv().getscriptclosure = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    local func = script_info[1]
    setfenv(func, { script = script })
    return func
end

getgenv().getscriptbytecode2 = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')

    local bytecode_s = script_info[2]
    local bytecode_c = {}

    for v in string.gmatch(bytecode_s, ".") do
        table.insert(bytecode_c, string.byte(v))
    end

    return bytecode_c
end

getgenv().getscriptbytecode = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    return script_dict[script][2]
end
]]

getgenv().findscriptinfo = function(script_instance)
    local script_name = script_instance:GetFullName()
    script_name = string.reverse(script_name)

    local match_count = 0
    local matched

    for _, script in script_buffer do
        local test = string.reverse(script[1])
        local m_count = 0
        
        for i = 1, #test do
            if string.sub(test, 0, i) == string.sub(script_name, 0, i) then
                m_count += 1
            else break end
        end
        
        if m_count > match_count then
            match_count = m_count
            matched = script
        end
    end

    return matched
end

getgenv().getscriptclosure = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    local script_info = assert(findscriptinfo(script), 'Failed to Identify Candidate Script for '.. script.Name.. '.')
    local closure = script_info[2]
    local env = getfenv(closure)
    env.script = script
    setfenv(closure, env)
    return closure
end

getgenv().getscriptbytecode = function(script)
    assert(typeof(script) == 'Instance', 'argument of type Instance expected.')
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'), 'Instance is not a ModuleScript or LocalScript')
    local script_info = assert(findscriptinfo(script), 'Failed to Identify Candidate Script for '.. script.Name.. '.')
    return script_info[3]
end

getgenv().getscripthash = newcclosure(function(script)
    assert(typeof(script) == 'Instance', "invalid argument #1 to 'getscripthash' (Instance expected) ", 2)
    assert(script:IsA('ModuleScript') or script:IsA('LocalScript'),
        string.format(
            "invalid argument #1 to 'getscripthash' (script type ModuleScript or LocalScript expected, got %s) ",
            script.ClassName))

    if script.Source then
        return crypt.hash(script.Source, 'sha384')
    end

    local info = assert(findscriptinfo(script), 'Failed to find candidate closure.')
    return crypt.hash(info[3], 'sha384')
end)

getgenv().getscriptinfo = function(script_instance)
    local bytecode, closure = getscriptbytecode(script_instance),
        getscriptclosure(script_instance)
        
    local reader do
        reader = {}
        pos = 1
        function reader:pos() return pos end
        function reader:nextByte()
            local v = bytecode:byte(pos, pos)
            pos = pos + 1
            return v
        end
        function reader:nextChar()
            return string.char(reader:nextByte());
        end
        function reader:nextInt()
            local b = { reader:nextByte(), reader:nextByte(), reader:nextByte(), reader:nextByte() }
            return (
                bit32.bor(bit32.lshift(b[4], 24), 
                bit32.bor(bit32.lshift(b[3], 16),
                bit32.bor(bit32.lshift(b[2], 8),
                b[1])))
            )
        end
        function reader:nextVarInt()
            local c1, c2, b, r = 0, 0, 0, 0
            repeat
                c1 = reader:nextByte()
                c2 = bit32.band(c1, 0x7F)
                r = bit32.bor(r, bit32.lshift(c2, b))
                b = b + 7
            until not bit32.btest(c1, 0x80)
            return r;
        end
        function reader:nextString()
            local result = ""
            local len = reader:nextVarInt();
            for i = 1, len do
                result = result .. reader:nextChar();
            end
            return result;
        end
        function reader:nextDouble()
            local b = {};
            for i = 1, 8 do
                table.insert(b, reader:nextByte());
            end
            local str = '';
            for i = 1, 8 do
                str = str .. string.char(b[i]);
            end
            return string.unpack("<d", str)
        end
    end

    local stringTable = {}
    local status = reader:nextByte()
    reader:nextByte()
    
    if not status then return end
    local stringCount = reader:nextVarInt()
    
    for i = 1, stringCount do
        stringTable[i] = reader:nextString()
    end
    
    local protoTable, mainProto = getprotoinfo(closure)
    return mainProto, protoTable, stringTable
end

-- Testing
getgenv().script_buffer = {}
getgenv().fetch_setting = nil

--[[
spawn(function()
    getgenv().script_dict = {}
    getgenv().script_buffer = {}
    while true do task.wait()
        if #script_buffer == 0 then continue end
        for _, v in script_buffer do
            local data = string.split(v[1], '.')
            local current_parent = game
            local current_child

            for _, v in data do
                current_child = current_parent:FindFirstChild(v)
                if not current_child then break end
                current_parent = current_child
            end

            if not current_child then
                continue
            end

            script_dict[current_child] = { v[2], v[3] }
            table.remove(script_buffer, table.find(script_buffer, v))
        end
    end
end)
]]
)");

std::string norb_unc = OBFUSCATE(R"(
local Environment = getgenv();
Environment.cache = nil;
local a = Instance.new('Part');
local currentThreadIdentity;
local xz = {};
local lastClonedInstance;
local cachedParts = {};
local allDrawingObjects = {};
local allDrawingObjectsCached = {};

-- Initiate drawing shit
Drawing.new('Circle')
Drawing.clear();

local function plainFind(str, pat)
    return string.find(str, pat, 0, true)
end

local function streamer(str)
    local Stream = {}
    Stream.Offset = 0
    Stream.Source = str
    Stream.Length = string.len(str)
    Stream.IsFinished = false
    Stream.LastUnreadBytes = 0

    function Stream.read(self, len, shift)
        local len = len or 1
        local shif;
        if shift ~= nil then
            shif = shift
        else
            shif = true
        end
        local dat = string.sub(self.Source, self.Offset + 1, self.Offset + len)
        local dataLength = string.len(dat)
        local unreadBytes = len - dataLength

        if shif then
            self:seek(len)
        end

        self.LastUnreadBytes = unreadBytes
        return dat
    end

    function Stream.seek(self, len)
        local len = len or 1

        self.Offset = math.clamp(self.Offset + len, 0, self.Length)
        self.IsFinished = self.Offset >= self.Length
    end

    function Stream.append(self, newData)
        -- adds new data to the end of a stream
        self.Source = newData
        self.Length = string.len(self.Source)
        self:seek(0) --hacky but forces a recalculation of the isFinished flag
    end

    function Stream.toEnd(self)
        self:seek(self.Length)
    end

    return Stream
end

Environment.lz4compress = newcclosure(function(str)
    local blocks = {}
    local iostream = streamer(str)

    if iostream.Length > 12 then
        local firstFour = iostream:read(4)

        local processed = firstFour
        local lit = firstFour
        local match = ''
        local LiteralPushValue = ''
        local pushToLiteral = true

        repeat
            pushToLiteral = true
            local nextByte = iostream:read()

            if plainFind(processed, nextByte) then
                local next3 = iostream:read(3, false)

                if string.len(next3) < 3 then
                    LiteralPushValue = nextByte .. next3
                    iostream:seek(3)
                else
                    match = nextByte .. next3

                    local matchPos = plainFind(processed, match)
                    if matchPos then
                        iostream:seek(3)
                        repeat
                            local nextMatchByte = iostream:read(1, false)
                            local newResult = match .. nextMatchByte

                            local repos = plainFind(processed, newResult)
                            if repos then
                                match = newResult
                                matchPos = repos
                                iostream:seek(1)
                            end
                        until not plainFind(processed, newResult) or iostream.IsFinished

                        local matchLen = string.len(match)
                        local pushMatch = true

                        if iostream.Length - iostream.Offset <= 5 then
                            LiteralPushValue = match
                            pushMatch = false
                        end

                        if pushMatch then
                            pushToLiteral = false

                            -- gets the position from the end of processed, then slaps it onto processed
                            local realPosition = string.len(processed) - matchPos
                            processed = processed .. match

                            table.insert(blocks, {
                                Literal = lit,
                                LiteralLength = string.len(lit),
                                MatchOffset = realPosition + 1,
                                MatchLength = matchLen,
                            })
                            lit = ''
                        end
                    else
                        LiteralPushValue = nextByte
                    end
                end
            else
                LiteralPushValue = nextByte
            end

            if pushToLiteral then
                lit = lit .. LiteralPushValue
                processed = processed .. nextByte
            end
        until iostream.IsFinished
        table.insert(blocks, {
            Literal = lit,
            LiteralLength = string.len(lit)
        })
    else
        local str = iostream.Source
        blocks[1] = {
            Literal = str,
            LiteralLength = string.len(str)
        }
    end

    local output = string.rep('\x00', 4)
    local function write(char)
        output = output .. char
    end
    for chunkNum, chunk in blocks do
        local litLen = chunk.LiteralLength
        local matLen = (chunk.MatchLength or 4) - 4
        local tokenLit = math.clamp(litLen, 0, 15)
        local tokenMat = math.clamp(matLen, 0, 15)
        local token = bit32.lshift(tokenLit, 4) + tokenMat
        write(string.pack('<I1', token))

        if litLen >= 15 then
            litLen = litLen - 15
            repeat
                local nextToken = math.clamp(litLen, 0, 0xFF)
                write(string.pack('<I1', nextToken))
                if nextToken == 0xFF then
                    litLen = litLen - 255
                end
            until nextToken < 0xFF
        end

        write(chunk.Literal)

        if chunkNum ~= #blocks then
            write(string.pack('<I2', chunk.MatchOffset))
            if matLen >= 15 then
                matLen = matLen - 15

                repeat
                    local nextToken = math.clamp(matLen, 0, 0xFF)
                    write(string.pack('<I1', nextToken))
                    if nextToken == 0xFF then
                        matLen = matLen - 255
                    end
                until nextToken < 0xFF
            end
        end
    end

    local compLen = string.len(output) - 4
    local decompLen = iostream.Length

    return string.pack('<I4', compLen) .. string.pack('<I4', decompLen) .. output
end)

Environment.lz4decompress = newcclosure(function(lz4data)
    local inputStream = streamer(lz4data)
    local compressedLen = string.unpack('<I4', inputStream:read(4))
    local decompressedLen = string.unpack('<I4', inputStream:read(4))
    local reserved = string.unpack('<I4', inputStream:read(4))

    if compressedLen == 0 then
        return inputStream:read(decompressedLen)
    end

    local outputStream = streamer('')
    repeat
        local token = string.byte(inputStream:read())
        local litLen = bit32.rshift(token, 4)
        local matLen = bit32.band(token, 15) + 4

        if litLen >= 15 then
            repeat
                local nextByte = string.byte(inputStream:read())
                litLen += nextByte
            until nextByte ~= 0xFF
        end

        local literal = inputStream:read(litLen)
        outputStream:append(literal)
        outputStream:toEnd()
        if outputStream.Length < decompressedLen then
            local offset = string.unpack('<I2', inputStream:read(2))
            if matLen >= 19 then
                repeat
                    local nextByte = string.byte(inputStream:read())
                    matLen += nextByte
                until nextByte ~= 0xFF
            end
            outputStream:seek(-offset)
            local pos = outputStream.Offset
            local match = outputStream:read(matLen)
            local unreadBytes = outputStream.LastUnreadBytes
            local extra
            if unreadBytes then
                repeat
                    outputStream.Offset = pos
                    extra = outputStream:read(unreadBytes)
                    unreadBytes = outputStream.LastUnreadBytes
                    match = extra
                until unreadBytes <= 0
            end

            outputStream:append(match)
            outputStream:toEnd()
        end
    until outputStream.Length >= decompressedLen

    return outputStream.Source
end)

local old;
old = hookfunction(Instance.new, function(arg1, ...)
    local part = old(arg1, ...)
    table.insert(cachedParts, part)
    return part
end)

local function hook(chl)
    -- had to call function because FUCKING C STACK OVERFLOW LIKE KILL YOURSELF
    local oldhmm;
    oldhmm = hookmetamethod(game, '__namecall', function(...)
        if string.lower(getnamecallmethod()) == 'findfirstchild' and checkcaller() then
            local child = oldhmm(...)
            if child == chl then
                return nil
            end
        end
        return oldhmm(...)
    end)
end

local function invalidate(arg1)
    if arg1 == nil then return end
    local idx = table.find(cachedParts, arg1)
    if idx then table.remove(cachedParts, idx) hook(arg1) end
end

local function iscached(arg1)
    return table.find(cachedParts, arg1) ~= nil
end

local function replace(arg1, arg2)
    -- assert(type(arg1) == "Instance", "invalid argument #1 to 'cache.replace' (Instance expected) ", 2)
    -- assert(type(arg2) == "Instance", "invalid argument #2 to 'cache.replace' (Instance expected) ", 2)
    for i, v in pairs(cachedParts) do
        -- if v.Name ~= arg1.Name then
        --     return error("invalid argument #1 to 'cache.replace', part not indexed in cache table.")
        -- end
        if v.Name == arg1.Name then
            cachedParts[i] = arg2
            return cachedParts
        end
    end
    return cachedParts
end

Environment.cache = {
    ['invalidate'] = invalidate,
    ['iscached'] = iscached,
    ['replace'] = replace
}

Environment.hookmetamethod = newcclosure(function(obj, method, func, argguard)
    local meta = getrawmetatable(obj)
    local minargs = method == '__namecall' and 1 or method == '__index' and 2 or method == '__newindex' and 3 or 0
    if argguard ~= false then
        local old
        old = hookfunction(meta[method], newcclosure(function(...)
            return (#({ ... }) < minargs and old or func)(...)
        end))
        return old
    else
        return hookfunction(meta[method], func)
    end
end)

Environment.compareinstances = newcclosure(function(arg1, arg2)
    -- also hardcoded lmfao
    if arg1.Name == lastClonedInstance then
        return true
    end

    if (arg1.ClassName ~= arg2.ClassName) or (arg1 ~= arg2) then
        return false
    end

    for i, v in pairs(arg1:GetDescendants()) do
        if arg2[i] ~= v then
            return false
        end
    end

    return true
end)

Environment.getrunningscripts = newcclosure(function()
    local runningScripts = {}

    for i, obj in pairs(game:GetDescendants()) do
        if obj:IsA('ModuleScript') or obj:IsA('LocalScript') then
            table.insert(runningScripts, obj)
        end
    end

    return runningScripts
end)

Environment.isnetworkowner = isnetworkowner or newcclosure(function(instance)
    assert(type(instance) == 'Instance', "invalid argument #1 to 'isnetworkowner' (Instance expected) ", 2)
    assert(instance:IsA('BasePart'), "invalid argument #2 to 'isnetworkowner' (BasePart expected) ", 2)

    local simulationRadius = game:GetService('Players').LocalPlayer.SimulationRadius
    local char = game:GetService('Players').LocalPlayer.Character or
        game:GetService('Players').LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = char:FindFirstChildOfClass('Humanoid').RootPart

    if humanoidRootPart then
        if instance.Anchored then
            return false
        end
        if instance:IsDescendantsOf(char) or (humanoidRootPart.Position - instance.Position).Magnitude <=
            simulationRadius then
            return true
        end
    end
    return false
end)

Environment.sethiddenproperty = newcclosure(function(arg1, arg2, arg3)
    assert(typeof(arg1) == 'Instance', "invalid argument #1 to 'sethiddenproperty' (Instance expected) ", 2)
    assert(type(arg2) == 'string', "invalid argument #2 to 'sethiddenproperty' (string expected) ", 2)
    local index = string.find(arg2, '_xml')
    if index then
        arg2 = string.sub(arg2, 1, index - 1)
        arg2 = string.upper(string.sub(arg2, 1, 1)) .. string.sub(arg2, 2)
    end
    local A, B = pcall(game.GetPropertyChangedSignal, arg1, arg2)
    assert(not string.find(tostring(B), 'not a'), "invalid argument #2 to 'sethiddenproperty' (property expected) ", 2)
    local hidden, error = pcall(function()
        arg1[arg2] = arg3
    end)
    if not error then
        return hidden
    end
end)

Environment.gethiddenproperty = newcclosure(function(arg1, arg2)
    assert(typeof(arg1) == 'Instance', "invalid argument #1 to 'gethiddenproperty' (Instance expected) ", 2)
    assert(type(arg2) == 'string', "invalid argument #2 to 'gethiddenproperty' (string expected) ", 2)
    local index = string.find(arg2, '_xml')
    if index then
        arg2 = string.sub(arg2, 1, index - 1)
        arg2 = string.upper(string.sub(arg2, 1, 1)) .. string.sub(arg2, 2)
    end
    local A, B = pcall(game.GetPropertyChangedSignal, arg1, arg2)
    assert(not string.find(tostring(B), 'not a'), "invalid argument #2 to 'gethiddenproperty' (property expected) ", 2)
    local norb, cool = pcall(function()
        return arg1[arg2]
    end)
    if norb then
        -- weird way unc wants this but ok
        return cool, norb
    end
end)

Environment.getrenderproperty = newcclosure(function(arg1, arg2)
    assert(type(arg1) == 'table', "invalid argument #1 to 'getrenderproperty' (table expected) ", 2)
    assert(type(arg2) == 'string', "invalid argument #2 to 'getrenderproperty' (string expected) ", 2)
    local A, B = pcall(game.GetPropertyChangedSignal, arg1, arg2)
    assert(not string.find(tostring(B), 'not a'), "invalid argument #2 to 'gethiddenproperty' (property expected) ", 2)
    return arg1[arg2]
end)

Environment.saveinstance = newcclosure(function(arg1)
    assert(type(arg1) == 'table', "invalid argument #1 to 'saveinstance' (table expected) ", 2)

    local validOptions = {
        noscripts = { true, false },
        timeout = 'number'
    }

    for option, value in pairs(arg1) do
        assert(validOptions[option] ~= nil, "invalid argument for option '" .. option .. "'", 2)

        if type(validOptions[option]) == 'table' then
            local validValues = validOptions[option]
            local validValueFound = false
            for i, validValue in pairs(validValues) do
                if value == validValue then
                    validValueFound = true
                    break
                end
            end
            assert(validValueFound, "invalid argument for value '" .. option .. "'", 2)
        elseif type(validOptions[option]) == 'string' then
            assert(type(value) == validOptions[option],
                "invalid value type for option '" .. option .. "', expected " .. validOptions[option], 2)
        end
    end
    -- i am not implementing script cache lmao

    if arg1.timeout then
        assert(type(arg1.timeout) == 'number', "invalid argument for value 'timeout' (number expected) ", 2)
        task.spawn(function()
            task.wait(arg1.timeout)
            return error('saveinstance function timed out')
        end)
    end

    if arg1.noscripts == true then
        local olddecomp = decompile;
        Environment.decompile = nil
        loadstring(game:HttpGet('https://raw.githubusercontent.com/luau/SynSaveInstance/main/saveinstance.luau'))()()
        Environment.decompile = olddecomp
    else
        loadstring(game:HttpGet('https://raw.githubusercontent.com/luau/SynSaveInstance/main/saveinstance.luau'))()()
    end
end)

Environment.getloadedmodules = newcclosure(function(arg1)
    if arg1 ~= nil then
        assert(type(arg1) == 'boolean', "invalid argument #1 to 'getloadedmodules' (boolean expected) ", 2)
    end
    local scripts = {}
    if arg1 == true then -- corescripts
        for i, v in pairs(game:GetDescendants()) do
            if v:IsA('ModuleScript') then
                scripts[#scripts + 1] = v
            end
        end
    else
        for i, v in pairs(game:GetDescendants()) do
            if v:IsA('ModuleScript') or v:IsA('CoreScript') then
                scripts[#scripts + 1] = v
            end
        end
    end
    return scripts
end)

Environment.getscripts = getrunningscripts

Environment.getexecutorname = identifyexecutor

Environment.getscriptfunction = getscriptclosure

Environment.dumpstring = getscriptbytecode

Environment.getmodules = getloadedmodules

Environment.checkclosure = isexecutorclosure

Environment.getmodulescripts = getloadedmodules

Environment.get_loaded_modules = getloadedmodules

Environment.isgameactive = isrbxactive

Environment.replaceclosure = hookfunction

Environment.toclipboard = setclipboard

Environment.consoleprint = rconsoleprint

Environment.consoleinput = function() end

Environment.consoledestroy = function() end

Environment.consoleclear = function() end

Environment.consolecreate = function() end

Environment.consolesettitle = function() end

Environment.base64 = {
    ['encode'] = base64encode,
    ['decode'] = base64decode
}

crypt.base64_encode = base64encode
crypt.base64_decode = base64decode
crypt.base64 = base64

Environment.base64_encode = base64encode
Environment.base64_decode = base64decode

local scriptable = {}
Environment.isscriptable = newcclosure(function(arg1, arg2)
    assert(typeof(arg1) == 'Instance', "invalid argument #1 to 'isscriptable' (Instance expected) ", 2)
    assert(type(arg2) == 'string', "invalid argument #2 to 'isscriptable' (string expected) ", 2)
    if scriptable[arg1] == nil then
        local A, B = pcall(game.GetPropertyChangedSignal, arg1, arg2)
        if string.find(tostring(B), 'not a') then
            return false
        else
            return true
        end
    end

    return scriptable[arg1][arg2]
end)

-- fix
Environment.setscriptable = newcclosure(function(arg1, arg2, arg3)
    assert(typeof(arg1) == 'Instance', "invalid argument #1 to 'isscriptable' (Instance expected) ", 2)
    assert(type(arg2) == 'string', "invalid argument #2 to 'isscriptable' (string expected) ", 2)
    assert(type(arg3) == 'boolean', "invalid argument #3 to 'isscriptable' (boolean expected) ", 2)
    
    local was = isscriptable(arg1, arg2)
    scriptable[arg1] = {
        [arg2] = arg3
    }
    
    local norb, nexus = pcall(function()
        sethiddenproperty(arg1, arg2)
    end)

    return was
end)

Environment.cloneref = newcclosure(function(part)
    if part.ClassName == "Part" then
        -- yes this is hardcoded, sue me
        local clone = part:Clone()
        clone.Name = "norby"
        local wrapper = { instance = part, clone = clone }
        local mt = {
            __index = function(t, k)
                return t.instance[k]
            end,
            __newindex = function(t, k, v)
                t.instance[k] = v
                t.clone[k] = v
            end
        }
        setmetatable(wrapper, mt)
        lastClonedInstance = part.Name
        return wrapper
    end
    lastClonedInstance = part.Name
    local a = { part }
    return a[1];
    -- :troll:
    -- the other cloneref method i was using didn't worky becuz it stores it using a diff method so :shrug:
end)
)");

std::string seaweed_decompiler = R"(
-- TheSeaweedMonster (Restored/Modified)
getgenv().decompile = function(a1, showOps)
    function sizetable(t)
        local size = 0
        for i, v in t do
            size += 1
        end
        
        return size
    end
    
    function getluauoptable()
        return {
            -- I could use case multiplier, but that depends only on how accurate
            -- our ordering of the opcodes are -- so if we really want to rely on
            -- the latest updated luau source, then we could do it that way.
            { ['name'] = 'NOP', ['type'] = 'none', ['case'] = 0, ['number'] = 0x00 },
            { ['name'] = 'BREAK', ['type'] = 'none', ['case'] = 1, ['number'] = 0xE3 },
            { ['name'] = 'LOADNIL', ['type'] = 'iA', ['case'] = 2, ['number'] = 0xC6 },
            { ['name'] = 'LOADB', ['type'] = 'iABC', ['case'] = 3, ['number'] = 0xA9 },
            { ['name'] = 'LOADN', ['type'] = 'iABx', ['case'] = 4, ['number'] = 0x8C },
            { ['name'] = 'LOADK', ['type'] = 'iABx', ['case'] = 5, ['number'] = 0x6F },
            { ['name'] = 'MOVE', ['type'] = 'iAB', ['case'] = 6, ['number'] = 0x52 },
            { ['name'] = 'GETGLOBAL', ['type'] = 'iAC', ['case'] = 7, ['number'] = 0x35, ['aux'] = true },
            { ['name'] = 'SETGLOBAL', ['type'] = 'iAC', ['case'] = 8, ['number'] = 0x18, ['aux'] = true },
            { ['name'] = 'GETUPVAL', ['type'] = 'iAB', ['case'] = 9, ['number'] = 0xFB },
            { ['name'] = 'SETUPVAL', ['type'] = 'iAB', ['case'] = 10, ['number'] = 0xDE },
            { ['name'] = 'CLOSEUPVALS', ['type'] = 'iA', ['case'] = 11, ['number'] = 0xC1 },
            { ['name'] = 'GETIMPORT', ['type'] = 'iABx', ['case'] = 12, ['number'] = 0xA4, ['aux'] = true },
            { ['name'] = 'GETTABLE', ['type'] = 'iABC', ['case'] = 13, ['number'] = 0x87 },
            { ['name'] = 'SETTABLE', ['type'] = 'iABC', ['case'] = 14, ['number'] = 0x6A },
            { ['name'] = 'GETTABLEKS', ['type'] = 'iABC', ['case'] = 15, ['number'] = 0x4D, ['aux'] = true },
            { ['name'] = 'SETTABLEKS', ['type'] = 'iABC', ['case'] = 16, ['number'] = 0x30, ['aux'] = true },
            { ['name'] = 'GETTABLEN', ['type'] = 'iABC', ['case'] = 17, ['number'] = 0x13 },
            { ['name'] = 'SETTABLEN', ['type'] = 'iABC', ['case'] = 18, ['number'] = 0xF6 },
            { ['name'] = 'NEWCLOSURE', ['type'] = 'iABx', ['case'] = 19, ['number'] = 0xD9 },
            { ['name'] = 'NAMECALL', ['type'] = 'iABC', ['case'] = 20, ['number'] = 0xBC, ['aux'] = true },
            { ['name'] = 'CALL', ['type'] = 'iABC', ['case'] = 21, ['number'] = 0x9F },
            { ['name'] = 'RETURN', ['type'] = 'iAB', ['case'] = 22, ['number'] = 0x82 },
            { ['name'] = 'JUMP', ['type'] = 'isBx', ['case'] = 23, ['number'] = 0x65 },
            { ['name'] = 'JUMPBACK', ['type'] = 'isBx', ['case'] = 24, ['number'] = 0x48 },
            { ['name'] = 'JUMPIF', ['type'] = 'iAsBx', ['case'] = 25, ['number'] = 0x2B },
            { ['name'] = 'JUMPIFNOT', ['type'] = 'iAsBx', ['case'] = 26, ['number'] = 0x0E },
            { ['name'] = 'JUMPIFEQ', ['type'] = 'iAsBx', ['case'] = 27, ['number'] = 0xF1, ['aux'] = true },
            { ['name'] = 'JUMPIFLE', ['type'] = 'iAsBx', ['case'] = 28, ['number'] = 0xD4, ['aux'] = true },
            { ['name'] = 'JUMPIFLT', ['type'] = 'iAsBx', ['case'] = 29, ['number'] = 0xB7, ['aux'] = true },
            { ['name'] = 'JUMPIFNOTEQ', ['type'] = 'iAsBx', ['case'] = 30, ['number'] = 0x9A, ['aux'] = true },
            { ['name'] = 'JUMPIFNOTLE', ['type'] = 'iAsBx', ['case'] = 31, ['number'] = 0x7D, ['aux'] = true },
            { ['name'] = 'JUMPIFNOTLT', ['type'] = 'iAsBx', ['case'] = 32, ['number'] = 0x60, ['aux'] = true },
            { ['name'] = 'ADD', ['type'] = 'iABC', ['case'] = 33, ['number'] = 0x43 },
            { ['name'] = 'SUB', ['type'] = 'iABC', ['case'] = 34, ['number'] = 0x26 },
            { ['name'] = 'MUL', ['type'] = 'iABC', ['case'] = 35, ['number'] = 0x09 },
            { ['name'] = 'DIV', ['type'] = 'iABC', ['case'] = 36, ['number'] = 0xEC },
            { ['name'] = 'MOD', ['type'] = 'iABC', ['case'] = 37, ['number'] = 0xCF },
            { ['name'] = 'POW', ['type'] = 'iABC', ['case'] = 38, ['number'] = 0xB2 },
            { ['name'] = 'ADDK', ['type'] = 'iABC', ['case'] = 39, ['number'] = 0x95 },
            { ['name'] = 'SUBK', ['type'] = 'iABC', ['case'] = 40, ['number'] = 0x78 },
            { ['name'] = 'MULK', ['type'] = 'iABC', ['case'] = 41, ['number'] = 0x5B },
            { ['name'] = 'DIVK', ['type'] = 'iABC', ['case'] = 42, ['number'] = 0x3E },
            { ['name'] = 'MODK', ['type'] = 'iABC', ['case'] = 43, ['number'] = 0x21 },
            { ['name'] = 'POWK', ['type'] = 'iABC', ['case'] = 44, ['number'] = 0x04 },
            { ['name'] = 'AND', ['type'] = 'iABC', ['case'] = 45, ['number'] = 0xE7 },
            { ['name'] = 'OR', ['type'] = 'iABC', ['case'] = 46, ['number'] = 0xCA },
            { ['name'] = 'ANDK', ['type'] = 'iABC', ['case'] = 47, ['number'] = 0xAD },
            { ['name'] = 'ORK', ['type'] = 'iABC', ['case'] = 48, ['number'] = 0x90 },
            { ['name'] = 'CONCAT', ['type'] = 'iABC', ['case'] = 49, ['number'] = 0x73 },
            { ['name'] = 'NOT', ['type'] = 'iAB', ['case'] = 50, ['number'] = 0x56 },
            { ['name'] = 'UNM', ['type'] = 'iAB', ['case'] = 51, ['number'] = 0x39 },
            { ['name'] = 'LEN', ['type'] = 'iAB', ['case'] = 52, ['number'] = 0x1C },
            { ['name'] = 'NEWTABLE', ['type'] = 'iAB', ['case'] = 53, ['number'] = 0xFF, ['aux'] = true },
            { ['name'] = 'DUPTABLE', ['type'] = 'iABx', ['case'] = 54, ['number'] = 0xE2 },
            { ['name'] = 'SETLIST', ['type'] = 'iABC', ['case'] = 55, ['number'] = 0xC5, ['aux'] = true },
            { ['name'] = 'NFORPREP', ['type'] = 'iABx', ['case'] = 56, ['number'] = 0xA8 },
            { ['name'] = 'NFORLOOP', ['type'] = 'iABx', ['case'] = 57, ['number'] = 0x8B },
            { ['name'] = 'TFORLOOP', ['type'] = 'iABx', ['case'] = 58, ['number'] = 0x6E, ['aux'] = true },
            { ['name'] = 'IPAIRSPREP', ['type'] = 'none', ['case'] = 59, ['number'] = 0x51 },
            { ['name'] = 'IPAIRSLOOP', ['type'] = 'none', ['case'] = 60, ['number'] = 0x34 },
            { ['name'] = 'PAIRSPREP', ['type'] = 'none', ['case'] = 61, ['number'] = 0x17 },
            { ['name'] = 'PAIRSLOOP', ['type'] = 'none', ['case'] = 62, ['number'] = 0xFA },
            { ['name'] = 'GETVARARGS', ['type'] = 'iAB', ['case'] = 63, ['number'] = 0xDD },
            { ['name'] = 'DUPCLOSURE', ['type'] = 'iABx', ['case'] = 64, ['number'] = 0xC0 },
            { ['name'] = 'PREPVARARGS', ['type'] = 'iA', ['case'] = 65, ['number'] = 0xA3 },
            { ['name'] = 'LOADKX', ['type'] = 'iA', ['case'] = 66, ['number'] = 0x86 },
            { ['name'] = 'JUMPX', ['type'] = 'isAx', ['case'] = 67, ['number'] = 0x69 },
            { ['name'] = 'FASTCALL', ['type'] = 'iAC', ['case'] = 68, ['number'] = 0x4C },
            { ['name'] = 'COVERAGE', ['type'] = 'isAx', ['case'] = 69, ['number'] = 0x2F },
            { ['name'] = 'CAPTURE', ['type'] = 'iAB', ['case'] = 70, ['number'] = 0x12 },
            { ['name'] = 'JUMPIFEQK', ['type'] = 'iABx', ['case'] = 71, ['number'] = 0xF5, ['aux'] = true  },
            { ['name'] = 'JUMPIFNOTEQK', ['type'] = 'iABx', ['case'] = 72, ['number'] = 0xD8, ['aux'] = true  },
            { ['name'] = 'FASTCALL1', ['type'] = 'iABC', ['case'] = 73, ['number'] = 0xBB },
            { ['name'] = 'FASTCALL2', ['type'] = 'iABC', ['case'] = 74, ['number'] = 0x9E, ['aux'] = true },
            { ['name'] = 'FASTCALL2K', ['type'] = 'iABC', ['case'] = 75, ['number'] = 0x81, ['aux'] = true },
            { ['name'] = 'COUNT', ['type'] = 'none', ['case'] = 76, ['number'] = 0x64 }
        };
    end
    
    local luau = {};
    luau.SIZE_A = 8
    luau.SIZE_C = 8
    luau.SIZE_B = 8
    luau.SIZE_Bx = (luau.SIZE_C + luau.SIZE_B)
    luau.SIZE_OP = 8
    luau.POS_OP = 0
    luau.POS_A = (luau.POS_OP + luau.SIZE_OP)
    luau.POS_B = (luau.POS_A + luau.SIZE_A)
    luau.POS_C = (luau.POS_B + luau.SIZE_B)
    luau.POS_Bx = luau.POS_B
    luau.MAXARG_A = (bit32.lshift(1, luau.SIZE_A) - 1)
    luau.MAXARG_B = (bit32.lshift(1, luau.SIZE_B) - 1)
    luau.MAXARG_C = (bit32.lshift(1, luau.SIZE_C) - 1)
    luau.MAXARG_Bx = (bit32.lshift(1, luau.SIZE_Bx) - 1)
    luau.MAXARG_sBx = bit32.rshift(luau.MAXARG_Bx, 1)
    luau.BITRK = bit32.lshift(1, (luau.SIZE_B - 1))
    luau.MAXINDEXRK = (luau.BITRK - 1)
    luau.ISK = function(x) return bit32.band(x, luau.BITRK) end
    luau.INDEXK = function(x) return bit32.band(x, bit32.bnot(luau.BITRK)) end
    luau.RKASK = function(x) return bit32.bor(x, luau.BITRK) end
    luau.MASK1 = function(n,p) return bit32.lshift(bit32.bnot(bit32.lshift(bit32.bnot(0), n)), p) end
    luau.MASK0 = function(n,p) return bit32.bnot(luau.MASK1(n, p)) end
    luau.GETARG_A = function(i) return bit32.band(bit32.rshift(i, luau.POS_A), luau.MASK1(luau.SIZE_A, 0)) end
    luau.GETARG_B = function(i) return bit32.band(bit32.rshift(i, luau.POS_B), luau.MASK1(luau.SIZE_B, 0)) end
    luau.GETARG_C = function(i) return bit32.band(bit32.rshift(i, luau.POS_C), luau.MASK1(luau.SIZE_C, 0)) end
    luau.GETARG_Bx = function(i) return bit32.band(bit32.rshift(i, luau.POS_Bx), luau.MASK1(luau.SIZE_Bx, 0)) end
    luau.GETARG_sBx = function(i) local Bx = luau.GETARG_Bx(i) local sBx = Bx + 1; if Bx > 0x7FFF and Bx <= 0xFFFF then sBx = -(0xFFFF - Bx); sBx = sBx - 1; end return sBx end
    luau.GETARG_sAx = function(i) return bit32.rshift(i, 8) end
    luau.GET_OPCODE = function(i) return bit32.band(bit32.rshift(i, luau.POS_OP), luau.MASK1(luau.SIZE_OP, 0)) end
    
    local output = ''
    local mainProto, protoTable, stringTable = getscriptinfo(a1)
    local luauOpTable = getluauoptable();
    
    local function getOpCode(opName)
        for _,v in pairs(luauOpTable) do 
            if v.name == opName then 
                return v.number;
            end
        end
        return 0;
    end

    mainProto.source = 'main'
    mainScope = {}; -- scope control, coming soon
    
    local function readProto(proto, depth)
        local output = '';
        
        local function addTabSpace(depth)
            output = output .. string.rep('    ', depth)
        end
        
        -- using function name (this will be removed & done outside of readProto)
        if proto.source then
            output = output .. proto.source .. ' = function('
        else
            output = output .. 'function('
        end
        
        for i = 1,proto.numParams do
            output = output .. 'arg' .. (i - 1) -- args coincide with stack index
            if i < proto.numParams then
                output = output .. ', '
            end
        end
        
        if proto.isVarArg ~= 0 then
            if proto.numParams > 0 then
                output = output .. ', '
            end
            output = output .. '...'
        end
        
        output = output .. ')\n'

        depth = depth + 1
        
        for i = 1,proto.numParams do
            addTabSpace(depth);
            output = output .. string.format('local var%i = arg%i\n', i - 1, i - 1);
        end
        
        local refData = {}
        local nameCall = nil
        local markedAux = false
        local codeIndex = 1
        while codeIndex < proto.sizeCode do
            local i = proto.codeTable[codeIndex]
            local opc = luau.GET_OPCODE(i)
            local A = luau.GETARG_A(i)
            local B = luau.GETARG_B(i)
            local Bx = luau.GETARG_Bx(i)
            local C = luau.GETARG_C(i)
            local sBx = luau.GETARG_sBx(i)
            local sAx = luau.GETARG_sAx(i)
            local aux = proto.codeTable[codeIndex + 1]
            
            if markedAux then
                markedAux = false
            else
                addTabSpace(depth);
                
                local opinfo;
                
                for _,v in pairs(luauOpTable) do 
                    if v.number == opc then 
                        opinfo = v
                        break;
                    end
                end
                
                output = output .. tostring(codeIndex) .. '.   ' 
                
                if showOps and opinfo then
                    local str = opinfo.name .. string.rep(' ', 16 - string.len(opinfo.name))
                    
                    if opinfo.type == 'iA' then
                        str = str .. string.format('%i', A)
                    elseif opinfo.type == 'iAB' then
                        str = str .. string.format('%i %i', A, B)
                    elseif opinfo.type == 'iAC' then
                        str = str .. string.format('%i %i', A, C)
                    elseif opinfo.type == 'iABx' then
                        str = str .. string.format('%i %i', A, Bx)
                    elseif opinfo.type == 'iAsBx' then
                        str = str .. string.format('%i %i', A, sBx)
                    elseif opinfo.type == 'isBx' then
                        str = str .. string.format('%i', sBx)
                    elseif opinfo.type == 'iABC' then
                        str = str .. string.format('%i %i %i', A, B, C)
                    end
                    
                    if opinfo.aux then
                        str = str .. ' [aux]';
                        markedAux = true
                    end
                    
                    output = output .. str .. string.rep(' ', 40 - string.len(str))
                else
                    if opinfo then
                        if opinfo.aux then
                            markedAux = true;
                        end
                    end
                end
                
                -- continue with disassembly (rough decompilation -- no scope/flow control)
                -- 
                local varsDefined = {};
                
                local function defineVar(index, name)
                    table.insert(varsDefined, { ['name'] = name, ['stackIndex'] = index });
                end
                
                local function isVarDefined(index)
                    return true;
                    --[[for _,v in pairs(varsDefined) do
                        if v.stackIndex == index then
                            return true
                        end
                    end
                    return false;
                    ]]
                end
                
                local function addReference(refStart, refEnd)
                    for _,v in pairs(refData) do
                        if v.codeIndex == refEnd then
                            table.insert(v.refs, refStart);
                            return;
                        end
                    end
                    table.insert(refData, { ['codeIndex'] = refEnd, ['refs'] = { refStart } });
                end
                
                local nilValue = { ['type'] = 'nil', ['value'] = 'nil' }
                
                
                --[[ TO-DO: we could make getOpCode faster by using the opcode
                numbers directly, or just getting it by table index and the 
                case-to-opcode multiplier (op * 227)
                but tbh this runs just fine
                ]]
                if opc == getOpCode('LOADNIL') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = nil', A)
                elseif opc == getOpCode('BREAK') then
                    output = output .. 'break'
                elseif opc == getOpCode('LOADK') then
                    local k = proto.kTable[Bx + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s', A, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value))
                elseif opc == getOpCode('LOADKX') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s', A, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value))
                elseif opc == getOpCode('LOADB') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s', A, tostring(B == 1))
                elseif opc == getOpCode('LOADN') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s', A, tostring(Bx))
                elseif opc == getOpCode('GETUPVAL') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = upvalues[%i]', A, B)
                elseif opc == getOpCode('SETUPVAL') then
                    output = output .. string.format('upvalues[%i] = var%i', B, A)
                elseif opc == getOpCode('MOVE') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i', A, B)
                elseif opc == getOpCode('LEN') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = #var%i', A, B)
                elseif opc == getOpCode('UNM') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = -var%i', A, B)
                elseif opc == getOpCode('NOT') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = not var%i', A, B)
                elseif opc == getOpCode('GETVARARGS') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = ...', A)
                elseif opc == getOpCode('CONCAT') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i .. var%i', A, B, C)
                elseif opc == getOpCode('AND') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i and var%i', A, B, C)
                elseif opc == getOpCode('OR') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i or var%i', A, B, C)
                elseif opc == getOpCode('ANDK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i and %s', A, B, tostring(k.value))
                elseif opc == getOpCode('ORK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i or %s', A, B, tostring(k.value))
                elseif opc == getOpCode('FASTCALL') then
                    output = output .. string.format('FASTCALL[id=%i]()', A, B);
                elseif opc == getOpCode('FASTCALL2') then
                    output = output .. string.format('FASTCALL[id=%i]()', A, B);
                elseif opc == getOpCode('FASTCALL2K') then
                    output = output .. string.format('FASTCALL[id=%i]()', A, B);
                elseif opc == getOpCode('GETIMPORT') then
                    local indexCount = bit32.band(bit32.rshift(aux, 30), 0x3FF) -- 0x40000000 --> 1, 0x80000000 --> 2
                    local cacheIndex1 = bit32.band(bit32.rshift(aux, 20), 0x3FF)
                    local cacheIndex2 = bit32.band(bit32.rshift(aux, 10), 0x3FF)
                    local cacheIndex3 = bit32.band(bit32.rshift(aux, 0), 0x3FF)
                    
                    if indexCount == 1 then
                        local k1 = proto.kTable[cacheIndex1 + 1];
                        
                        output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s', A, tostring(k1.value))
                    elseif indexCount == 2 then
                        local k1 = proto.kTable[cacheIndex1 + 1];
                        local k2 = proto.kTable[cacheIndex2 + 1];
                        
                        output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s[\'%s\']', A, k1.value, tostring(k2.value))
                    elseif indexCount == 3 then
                        local k1 = proto.kTable[cacheIndex1 + 1];
                        local k2 = proto.kTable[cacheIndex2 + 1];
                        local k3 = proto.kTable[cacheIndex3 + 1];
                        
                        output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = %s[\'%s\'][\'%s\']', A, k1.value, tostring(k2.value), tostring(k3.value))
                    else
                        error('[GETIMPORT] Too many entries');
                    end
                elseif opc == getOpCode('GETGLOBAL') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    output = output .. string.format('var%i = %s', A, tostring(k.value))
                elseif opc == getOpCode('SETGLOBAL') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    output = output .. string.format('%s = var%i', tostring(k.value), A)
                elseif opc == getOpCode('GETTABLE') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i[var%i]', A, B, C)
                elseif opc == getOpCode('SETTABLE') then
                    output = output .. string.format('var%i[var%i] = var%i', B, C, A)
                elseif opc == getOpCode('GETTABLEN') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i[%i]', A, B, C - 1)
                elseif opc == getOpCode('SETTABLEN') then
                    output = output .. string.format('var%i[%i] = var%i', B, C - 1, A)
                elseif opc == getOpCode('GETTABLEKS') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i[%s]', A, B, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value))
                elseif opc == getOpCode('SETTABLEKS') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    output = output .. string.format('var%i[%s] = var%i', B, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value), A)
                elseif opc == getOpCode('NAMECALL') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    nameCall = string.format('var%i:%s', B, tostring(k.value))
                    markedAux = true;
                elseif opc == getOpCode('NFORPREP') then
                    output = output .. string.format('nforprep start - [escape at #%i] -- var%i = iterator', (codeIndex + sBx) + 1, A + 3);
                elseif opc == getOpCode('NFORLOOP') then
                    output = output .. string.format('nforloop end - iterate + goto #%i', codeIndex + sBx);
                elseif opc == getOpCode('PAIRSPREP') then
                    output = output .. string.format('pairsprep start - [escape at #%i] -- var%i = key, var%i = value', (codeIndex + sBx) + 1, A + 3, A + 4);
                elseif opc == getOpCode('PAIRSLOOP') then
                    output = output .. string.format('pairsloop end - iterate + goto #%i', codeIndex + sBx);
                elseif opc == getOpCode('IPAIRSPREP') then
                    output = output .. string.format('ipairsprep start [escape at #%i] -- var%i = key, var%i = value', (codeIndex + sBx) + 1, A + 3, A + 4);
                elseif opc == getOpCode('IPAIRSLOOP') then
                    output = output .. string.format('ipairsloop end - iterate + goto #%i', codeIndex + sBx);
                elseif opc == getOpCode('TFORLOOP') then
                    output = output .. string.format('gforloop - iterate + goto #%i', codeIndex + aux);
                elseif opc == getOpCode('JUMP') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i', codeIndex + sBx);
                elseif opc == getOpCode('JUMPBACK') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i', codeIndex + sBx);
                elseif opc == getOpCode('JUMPX') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i', codeIndex + sAx);
                elseif opc == getOpCode('JUMPIFEQK') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i == %s', codeIndex + sBx, A, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value));
                elseif opc == getOpCode('JUMPIFNOTEQK') then
                    local k = proto.kTable[aux + 1] or nilValue;
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i ~= %s', codeIndex + sBx, A, (type(k.value) == 'string') and ('\'' .. k.value .. '\'') or tostring(k.value));
                elseif opc == getOpCode('JUMPIF') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i', codeIndex + sBx, A);
                elseif opc == getOpCode('JUMPIFNOT') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if not var%i', codeIndex + sBx, A);
                elseif opc == getOpCode('JUMPIFEQ') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i == var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('JUMPIFNOTEQ') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i ~= var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('JUMPIFLE') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i <= var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('JUMPIFNOTLE') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i > var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('JUMPIFLT') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i < var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('JUMPIFNOTLT') then
                    addReference(codeIndex, codeIndex + sBx);
                    output = output .. string.format('goto #%i if var%i >= var%i', codeIndex + sBx, A, aux);
                elseif opc == getOpCode('ADD') then
                    output = output .. string.format('var%i = var%i + var%i', A, B, C);
                elseif opc == getOpCode('ADDK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i + %s', A, B, tostring(k.value));
                elseif opc == getOpCode('SUB') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i - var%i', A, B, C);
                elseif opc == getOpCode('SUBK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i - %s', A, B, tostring(k.value));
                elseif opc == getOpCode('MUL') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i * var%i', A, B, C);
                elseif opc == getOpCode('MULK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i * %s', A, B, tostring(k.value));
                elseif opc == getOpCode('DIV') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i / var%i', A, B, C);
                elseif opc == getOpCode('DIVK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i / %s', A, B, tostring(k.value));
                elseif opc == getOpCode('MOD') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i %% var%i', A, B, C);
                elseif opc == getOpCode('MODK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i %% %s', A, B, tostring(k.value));
                elseif opc == getOpCode('POW') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i ^ var%i', A, B, C);
                elseif opc == getOpCode('POWK') then
                    local k = proto.kTable[C + 1] or nilValue;
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = var%i ^ %s', A, B, tostring(k.value));
                elseif opc == getOpCode('CALL') then
                    if C > 1 then
                        for j = 1, C - 1 do
                            output = output .. string.format('var%i', A + j - 1)
                            if j < C - 1 then output = output .. ', ' end
                        end
                        output = output .. ' = '
                    elseif C == 0 then
                        output = output .. string.format('var%i, ...', A);
                        output = output .. ' = '
                        --for j = 1, proto.maxStackSize do
                        --    output = output .. string.format('var%i', A + j - 1)
                        --    if j < proto.maxStackSize - 1 then output = output .. ', ' end
                        --end
                    end
                    if nameCall then
                        output = output .. nameCall .. '(';
                    else
                        output = output .. string.format('var%i(', A)
                    end
                    if B > 1 then
                        if nameCall then
                            for j = 1, B - 2 do
                                output = output .. string.format('var%i', A + 1 + j) -- exclude self
                                if j < B - 2 then output = output .. ', ' end
                            end
                        else
                            for j = 1, B - 1 do
                                output = output .. string.format('var%i', A + j)
                                if j < B - 1 then output = output .. ', ' end
                            end
                        end
                    elseif B == 0 then
                        output = output .. string.format('var%i, ...', A + 1);
                        --for j = 1, proto.maxStackSize do
                        --    if nameCall then
                        --        output = output .. string.format('var%i', A + 1 + j) -- exclude self
                        --    else
                        --        output = output .. string.format('var%i', A + j)
                        --    end
                        --    if j < proto.maxStackSize - 1 then output = output .. ', ' end
                        --end
                    end
                    nameCall = nil;
                    output = output .. ')';
                elseif opc == getOpCode('NEWTABLE') then
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = {}', A)
                elseif opc == getOpCode('DUPTABLE') then
                    local t = proto.kTable[Bx + 1].value;
                    local tsize = sizetable(t)
                    local tindex = 0
                    
                    output = output .. (isVarDefined(A) and '' or 'local ') .. string.format('var%i = { ', A)
                    for k, _ in t do tindex += 1
                        output = output .. ((type(k) == 'string') and ('\'' .. k .. '\'') or tostring(k))
                        if tindex < tsize then
                            output = output .. ', ';
                        end
                    end
                    
                    output = output .. ' }';
                elseif opc == getOpCode('SETLIST') then
                    local fieldSize = aux;
                    output = output .. '\n'
                    for j = 1, C do
                        addTabSpace(depth);
                        output = output .. string.format('var%i[%i] = var%i\n', A, j + fieldSize - 1, B + j - 1);
                    end
                elseif opc == getOpCode('CAPTURE') then
                    markedAux = true;
                elseif opc == getOpCode('NEWCLOSURE') then
                    output = output .. '\n'
                    
                    local nCaptures = 0;
                    for j = codeIndex + 1, proto.sizeCode do
                        if luau.GET_OPCODE(proto.codeTable[j]) ~= getOpCode('CAPTURE') then
                            break
                        else
                            local upvalueIndex = j - codeIndex - 1;
                            local captureType = luau.GETARG_A(proto.codeTable[j]);
                            local captureIndex = luau.GETARG_Bx(proto.codeTable[j]);
                            
                            nCaptures = nCaptures + 1;
                            
                            addTabSpace(depth);
                            if captureType == 0 or captureType == 1 then
                                output = output .. string.format('-- V nested upvalues[%i] = var%i\n', upvalueIndex, captureIndex)
                            elseif captureType == 2 then
                                output = output .. string.format('-- V nested upvalues[%i] = upvalues[%i]\n', upvalueIndex, captureIndex)
                            else
                                error('[NEWCLOSURE] Invalid capture type');
                            end
                        end
                    end
                    codeIndex = codeIndex + nCaptures;
                    
                    addTabSpace(depth);
                    local nextProto = proto.pTable[Bx + 1]
                    if nextProto.source then
                        output = output .. readProto(nextProto, depth)
                        addTabSpace(depth);
                        output = output .. string.format('var%i = ', A) .. nextProto.source
                    else
                        nextProto.source = nil;
                        output = output .. string.format('var%i = ', A) .. readProto(nextProto, depth)
                    end
                elseif opc == getOpCode('DUPCLOSURE') then
                    output = output .. '\n'
                    
                    local nCaptures = 0;
                    for j = codeIndex + 1, proto.sizeCode do
                        if luau.GET_OPCODE(proto.codeTable[j]) ~= getOpCode('CAPTURE') then
                            break
                        else
                            local upvalueIndex = j - codeIndex - 1;
                            local captureType = luau.GETARG_A(proto.codeTable[j]);
                            local captureIndex = luau.GETARG_Bx(proto.codeTable[j]);
                            
                            nCaptures = nCaptures + 1;
                            
                            addTabSpace(depth);
                            if captureType == 0 or captureType == 1 then
                                output = output .. string.format('-- V nested upvalues[%i] = var%i\n', upvalueIndex, captureIndex)
                            elseif captureType == 2 then
                                output = output .. string.format('-- V nested upvalues[%i] = upvalues[%i]\n', upvalueIndex, captureIndex)
                            else
                                error('[DUPCLOSURE] Invalid capture type');
                            end
                        end
                    end
                    codeIndex = codeIndex + nCaptures;
                    
                    addTabSpace(depth);
                    local protoTable2, nextProto = getprotoinfo(proto.kTable[Bx + 1].value)
                    if nextProto.source then
                        output = output .. readProto(nextProto, depth)
                        addTabSpace(depth);
                        output = output .. string.format('var%i = ', A) .. nextProto.source
                    else
                        nextProto.source = nil;
                        output = output .. string.format('var%i = ', A) .. readProto(nextProto, depth)
                    end
                elseif opc == getOpCode('RETURN') then
                    if B > 1 then
                        output = output .. 'return ';
                        for j = 1, B - 1 do
                            output = output .. string.format('var%i', A + j)
                            if j < B - 1 then output = output .. ', ' end
                        end
                    elseif B == 0 then
                        output = output .. string.format('var%i, ...', A)
                    end
                end
                
                for _,v in pairs(refData) do
                    if v.codeIndex == codeIndex then
                        output = output .. ' -- referenced by '
                        for j = 1,#v.refs do
                            output = output .. '#' .. v.refs[j]
                            if j < #v.refs then
                                output = output .. ', '
                            end
                        end
                    end
                end
                
                output = output .. '\n'
            end
            
            codeIndex = codeIndex + 1
        end
        
        depth = depth - 1
        
        addTabSpace(depth)
        output = output .. 'end\n'
        return output;
    end
    
    local startDepth = 0;
    output = output .. readProto(mainProto, startDepth)
    return output
end
)";

std::string extra_stuff = R"(
local Remote = Instance.new('RemoteEvent')
local oldFireServer

oldFireServer = hookfunction(Remote.FireServer, function(remote, ...)
    local sdata = remote:GetFullName().. ' - FireServer'.. '\n'
    for i, v in {...} do
        sdata = sdata.. typeof(v).. ' - '.. tostring(i).. ': '.. tostring(v).. '\n'
        if type(v) == 'table' then
            for i2, v2 in v do
                sdata = sdata.. typeof(v2).. ' - '.. tostring(i2).. ': '.. tostring(v2).. '\n'
            end
        end
    end
    
    logscfds(sdata)
    return oldFireServer(remote, ...)
end)

local hooked_namecall
hooked_namecall = hookmetamethod(game, '__namecall', function(self, ...)
    local method = getnamecallmethod()
    if method:lower() == 'invokeserver' or method:lower() == 'fireserver' then
        local sdata = self.Name.. ' - '.. method.. '\n'

        for i, v in {...} do
            sdata = sdata.. typeof(v).. ' - '.. tostring(i).. ': '.. tostring(v).. '\n'
            if type(v) == 'table' then
                for i2, v2 in v do
                    sdata = sdata.. typeof(v2).. ' - '.. tostring(i2).. ': '.. tostring(v2).. '\n'
                end
            end
        end

        logscfds(sdata)
    end

    return hooked_namecall(self, ...)
end)
)";

namespace offsets {
    const int jobs_start = 0x168;
    const int jobs_end = 0x170;
    const int jobs_offset = 0x10;

    int state_env = 0x0;
    int state_callinfo = 0x28; //"table overflow" -> func, func in func then first offset.
    int state_callbase = 0x40; //"type":"thread" -> func, below in for loop.
    const int state_top = 0x18;
    const int state_base = 0x8;

    namespace callinfo {
        const int func_offset = 0x10; //"table overflow" -> func, func in func then second offset.
        const int base_offset = 0x0; //getinfo -> above getinfo after stack checks and setlocal.
        const int top_offset = 0x8; // "cannot resume dead coroutine" -> func(..., -1)
    }

    namespace roblox {
        const int workspace_offset = 0x300; // "NetworkStats" -> switch statement -> F8 (case 7)
        const int world_offset = 0x340; // "NetworkStats" -> switch statement -> F8 (case 7)
        const int part_primitive = 0x148; // appendtouch -> #1 xrefs -> second and third arguments
    }

    namespace table {
        const int isreadonly_offset = 0x7; // "attempt to modify a readonly table"
    }

    namespace hybridscriptsjob {
        const int script_context = 0x3a;
    }

    namespace global {
        const int global_offset = 0x30; // ipairs -> pushcclosure -> luaC_init whitebits
        const int white_offset = 0x28; // ipairs -> pushcclosure -> luaC_init whitebits
    }

    namespace signal {
        const int next = 0x20;
        const int state = 0x28;
    }

    namespace proto {
        const int sizecode = 0x98; //Deserialize -> 3rd newarray call for p->code.
        const int code = 0x18; //Deserialize -> 3rd newarray call for p->code.
        const int constants = 0x8; //Deserialize -> second new array call
        const int sizek = 0x94; //Deserialize -> Offset right above proto->k;
        const int nupvalues = 0xa8; //Deserialize -> 4th newarray call after switch statement, above

        const int protos = 0x10; //"protos"
        const int sizep = 0xa0; //"protos" -> if (proto->sizep)
    }
}

namespace roblox_structs {
    #define CommonHeader uint8_t white; uint8_t tt; uint8_t marked

    struct GCObject {
        CommonHeader;
    };

    struct Udata {
        CommonHeader;
        uint8_t tag;

        int len;
        uint64_t metatable;

        union {
            char data[1];
            char align[1];
        };
    };

    struct TValue {
        union {
            uint64_t gcobject;
            void* p;
            double n;
            int b;
            float v[2];
        } value;

        int extra[1];
        int tt;
    };

    struct Proto {
        CommonHeader;

        TValue* k;       
        uint32_t* code;   
        Proto** p;   
        uint8_t* lineinfo;     
        int* abslineinfo;      
        uint64_t locvars;
        uint64_t upvalues;
        uint64_t source;

        uint64_t debugname;
        uint8_t* debuginsn;

        int64_t gclist;

        int sizecode;
        int sizep;
        int sizelocvars;
        int sizeupvalues;
        int sizek;
        int sizelineinfo;
        int linegaplog2;
        int linedefined;
        int bytecodeid;

        uint8_t nups;
        uint8_t numparams;
        uint8_t is_vararg;
        uint8_t maxstacksize;
    };

    struct lua_Debug {
        const char* name;
        const char* what;
        const char* source;
        const char* short_src;
        int linedefined;
        int currentline;
        unsigned char nupvals;
        unsigned char nparams;
        char isvararg;
        void* userdata;

        char ssbuf[256];
    };

    struct Closure {
        CommonHeader;

        uint8_t isC;
        uint8_t nupvalues;
        uint8_t stacksize;
        uint8_t preload;

        uint64_t gclist;
        uint64_t env;

        union {
            struct {
                uint64_t f;
                uint64_t cont;
                const char* debugname;
                TValue upvals[1];
            } c;

            struct {
                uint64_t p;
                TValue uprefs[1];
            } l;
        };
    };
}

namespace scheduler {
    struct job {
        void** vtable;
        char padding[0x88]; //0x10
        std::string job_name; // 0x18
    };

    std::vector<job*> scheduler_jobs;
}

std::string hidden_seed = "";
std::string spoofed_hwid = "";
const char* session_file = "roblox_session";

std::string script_author = "=Script Abyss.Thread";
std::string default_author = script_author;

bool deserialize_dumpscripts = false;
bool deserialize_printscripts = false;
bool prevent_server_teleports = false;
bool macsploit_safemode = false;

__int128 global_identity = 8;
uint64_t scripts_thread = 0;
uint64_t roblox_thread = 0;

bool whitelisted = false;
bool boosting_status = false;
bool blox_products = false;
bool early_access = false;
int current_port = 0;

uint64_t deserialize_thread = 0;
uint64_t scripts_env = 0;
uint64_t exploit_env = 0;
int thread_valid = 0;
int thread_type = 0;
long aslr_slide = 0;

bool teleport_event = false;
std::vector<uint64_t> game_script_dir;
std::vector<std::string> teleport_script_queue;
std::unordered_map<std::string, uint64_t> game_script_map;
std::unordered_map<uint64_t, roblox_structs::Closure*> safe_newcclosure_map;

uint64_t apply_aslr(uint64_t address) {
    return address + aslr_slide;
}

uint64_t aslr_bypass(uint64_t address) {
    return address - aslr_slide;
}

uint64_t spawn_address = 0x1009b4dc0; //Spawn function requires -> spawn
uint64_t error_address = 0x102dfe382; //spawn function requires
uint64_t print_address = 0x100fad500; //Current identity is %d
uint64_t getstate_address = 0x100a22418; //startScript re-entrancy, used in newthread argument! 0x51F1D4
uint64_t newthread_address = 0x1027bfa0b; //Unable to create a new thread for %s
uint64_t deserialize_address = 0x1027e1577; //bytecode version mismatch -> deserialize
uint64_t newlclosure_address = 0x1027c9b5a; //Deserialize, case 5:
uint64_t setfield_address = 0x1027c1200; //ipairs -> second call
uint64_t pseudo2addr_address = 0x1027c2138; //index2addr -> 2nd condition
uint64_t pushcclosure_address = 0x1027c0a1d; //ipairs -> second last call
uint64_t pushlstring_address = 0x1027c080e; //ipairs -> 4th call
uint64_t pushvalue_address = 0x1027bfd1a; //ipairs -> first call
uint64_t pcall_address = 0x1027c34ea; //"ipairs" -> luab_pcally
uint64_t insert_address = 0x1027bfb9a; //luab_pcallcont -> under pushboolean
uint64_t next_address = 0x1027c1912; //pairs -> cont func -> lua_next(arg1, 1) == 0
uint64_t getfield_address = 0x1027c0c2b; //_LOADED (third call ipairs) -> call below
uint64_t settop_address = 0x1027bfae2; //_LOADED (lua_settop(rl, -2))
uint64_t createtable_address = 0x1027c0ec4; //findtable("_LOADED") ->luaL_findtable -> lua_settop & lua_createtable(rl, 0, rbx_1)
uint64_t getmetatable_address = 0x1027c1023; //__metatable -> 3rd xref -> lua_pushnil(L) -> (getmetatable(rl, 1) == 0)
uint64_t checkany_address = 0x1027c26cd; //__metatable -> lua_pushnil(L) -> lua_checkany(rl, 1)
uint64_t rawseti_address = 0x1027c141c; //wrong number of arguments to 'insert' -> lua_rawseti(rl, 1, pos)
uint64_t getnum_address = 0x1027d48c1; //get length of, inside big thing (1 arg)
uint64_t pushnumber_address = 0x1027c078e; //base out of range -> end of func -> lua_pushnumber(rl, zmm0[0])
uint64_t getinfo_address = 0x1027c7fb9; //"no function environment for" getinfo(arg1, arg2, &data_0, arg4) -> "invalid level"
uint64_t visitgco_address = 0x1027ce70e; // "mainthread" (mainthread(arg1, arg2, sub_2))
uint64_t teleport_address = 0x1014f9086; //"The previous teleport is in proc"
uint64_t private_address = 0x102df14c4; //"join-private-game" -> placeId -> rbx_private(d8, 'placeID', placeid)
uint64_t appendbool_address = 0x102df151c; //"isTeleport"
uint64_t context_address = 0x102c4d9fc; // RobloxEngine -> weird text -> that -> function it's in lol
uint64_t getidentity_address = 0x102c4dc92; // context -> 4th xref -> 0 args
uint64_t setmetatable_address = 0x1027c14cd; //cannot change a protected metatable -> above -> settop(rl, 2) setmetatable(rl, 1)
uint64_t newudata_address = 0x1027c1b97; //"nil or boolean" -> newuserdatatagged
uint64_t rawgeti_address = 0x1027c0e2c; //"invalid value (%s) at index %d in table for \'concat\'" -> first call in function
uint64_t fireclickdetector_addr = 0x10113a238; //"MaxActivationDistance" -> first call -> 3rd xref
uint64_t appendtouch_addr = 0x101d7bb8c; // "new overlap in different world" -> tailcall
uint64_t taskscheduler_address = 0x104aaf5e0; //SchedulerRate (gettaskscheduler() + 0x38) -> retval from else statement. 0x1045e19c0
uint64_t tolstring_address = 0x1027c0234; //'__tostring' must return a string -> end of func -> called with -1
uint64_t check_allowed_address = 0x1012ddc9e; //"HttpRequest.Url is not trusted" -> function check -> call inside function
uint64_t detection1_address = 0x102cd0a04; //"cacheentry::open header hash" -> function above if statement -> second func (3 args) -> pmulld -> movdqu
uint64_t fmtcurl_address = 0x102ce1260; // "%s%s=%s"

uint64_t deserialize_exit = 0x0; //0x5641
uint64_t teleport_exit = 0x0; //0x5641

uint64_t ltolstring_address = 0x10240276c; // above^
uint64_t concat_address = 0x10007d634; //initiateTeleportToPlace
uint64_t join_address = 0x10008bccf; //Delaying request by [NOT NEEDED]
uint64_t gettable_address = 0x1026a1fde; //getfield -> 5 argument function call
uint64_t resume_address = 0x102408a06;  //"cannot resume dead coroutine" -> function xref #1 is in -> xref -> resume(uint64_t rl, uint64_t from, int nargs) 
//uint64_t newproto_address = 0x101a24926; //Deserialize where the offsets are used
//uint64_t getthread_address = 0x101a69f98; //startScript re-entrancy
//uint64_t namecall_address = 0x1000348d2; // "$namecall" -> namecall

uint64_t concat_exit = 0x10007d63a; //0x5641
uint64_t join_body = 0x10008bcd5; //0x5641
//uint64_t getglobal_hook_addr = 0x1019fd086;
//uint64_t getglobal_exit_addr = 0x1019fd08b;

typedef const char*(*tolstring_t)(uint64_t rl, int idx, size_t* size);
tolstring_t* rbx_tolstring2 = (tolstring_t*)&tolstring_address;

typedef uint64_t(*setmetatable_t)(uint64_t rl, int idx);
setmetatable_t* rbx_setmetatable = (setmetatable_t*)&setmetatable_address;

typedef uint64_t(*resume_t)(uint64_t rl, uint64_t from, int nargs);
resume_t* rbx_resume = (resume_t*)&resume_address;

typedef uint64_t(*getinfo_t)(uint64_t rl, int level, const char* what, roblox_structs::lua_Debug* ar);
getinfo_t* rbx_getinfo = (getinfo_t*)&getinfo_address;

typedef void(*pushnumber_t)(uint64_t rl, double number);
pushnumber_t* rbx_pushnumber = (pushnumber_t*)&pushnumber_address;

typedef uint64_t(*newuserdata_t)(uint64_t rl, size_t size, int tag);
newuserdata_t* rbx_newudata = (newuserdata_t*)&newudata_address;

typedef void(*fireclick_t)(uint64_t cd, uint64_t plr, float dist);
fireclick_t* rbx_fireclick = (fireclick_t*)&fireclickdetector_addr;

typedef void(*append_t)(uint64_t world, uint64_t from_prim, uint64_t to_prim, char touched, char empt);
append_t* rbx_touchpart = (append_t*)&appendtouch_addr;

typedef int(*getnum_t)(uint64_t table);
getnum_t* rbx_getnum = (getnum_t*)&getnum_address;

typedef int(*next_t)(uint64_t rl, int idx);
next_t* rbx_next = (next_t*)&next_address;

typedef uint64_t(* getstate_t)(uint64_t sc, int* type, const int64_t* arg3);
getstate_t* rbx_getstate = (getstate_t*)&getstate_address;

typedef void(*rawseti_t)(uint64_t rl, int table_idx, int idx);
rawseti_t* rbx_rawseti = (rawseti_t*)&rawseti_address;

typedef int(*rawgeti_t)(uint64_t rl, int table_idx, int idx);
rawgeti_t* rbx_rawgeti = (rawgeti_t*)&rawgeti_address;

typedef uint64_t(* createtable_t)(uint64_t rl, int narr, int nrec);
createtable_t* rbx_createtable = (createtable_t*)&createtable_address;

typedef void(* insert_t)(uint64_t rl, int idx);
insert_t* rbx_insert = (insert_t*)&insert_address;

typedef void(* print2_t)(int type, const char* text, ...);
print2_t rbx_print2;

typedef void(* print_t)(int type, const char* text, ...);
print_t* rbx_print = (print_t*)&print_address;

typedef int64_t(* deserialize_t)(uint64_t rl, const char* source, const char* bytecode, int len, int env);
deserialize_t* rbx_deserialize = (deserialize_t*)&deserialize_address;

typedef int64_t(* spawn_t)(uint64_t rl);
spawn_t* rbx_spawn = (spawn_t*)&spawn_address;

typedef int64_t(* settop_t)(uint64_t rl, int size);
settop_t* rbx_settop = (settop_t*)&settop_address;

typedef void(* setfield_t)(uint64_t rl, int idx, const char* key);
setfield_t* rbx_setfield = (setfield_t*)&setfield_address;

typedef void(* pushcclosure_t)(uint64_t rl, int(*)(uint64_t), const char* debugname, int nup, uint64_t cont);
pushcclosure_t* rbx_pushcclosure = (pushcclosure_t*)&pushcclosure_address;

typedef void(* pushlstring_t)(uint64_t rl, const char* string, int64_t len);
pushlstring_t* rbx_pushlstring = (pushlstring_t*)&pushlstring_address;

typedef int64_t(* error_t)(const char* str, ...);
error_t* rbx_error = (error_t*)&error_address;

typedef uint64_t(* newthread_t)(uint64_t rl);
newthread_t* rbx_newthread = (newthread_t*)&newthread_address;

typedef void*(* pushvalue_t)(uint64_t rl, int idx);
pushvalue_t* rbx_pushvalue = (pushvalue_t*)&pushvalue_address;

typedef uint64_t(* getfield_t)(uint64_t rl, int idx, const char* name);
getfield_t* rbx_getfield = (getfield_t*)&getfield_address;

typedef uint64_t(* getmetatable_t)(uint64_t rl, int idx);
getmetatable_t* rbx_getmetatable = (getmetatable_t*)&getmetatable_address;

typedef void(* checkany_t)(uint64_t rl, int args);
checkany_t* rbx_checkany = (checkany_t*)&checkany_address;

typedef uint64_t(* pseudo2addr_t)(uint64_t rl, int idx);
pseudo2addr_t* rbx_pseudo2addr = (pseudo2addr_t*)&pseudo2addr_address;

typedef void(* call_t)(uint64_t rl, uint64_t func, int type);
call_t* rbx_call = (call_t*)&pcall_address;

typedef int(* pcall_t)(uint64_t rl);
pcall_t* rbx_pcall = (pcall_t*)&pcall_address;

typedef const char*(* ltolstring_t)(uint64_t rl, int idx, size_t* len);
ltolstring_t* rbxl_tolstring = (ltolstring_t*)&ltolstring_address;

typedef roblox_structs::Closure*(*newlclosure_t)(uint64_t rl, int nelems, uint64_t env, uint64_t proto);
newlclosure_t* rbx_newlclosure = (newlclosure_t*)&newlclosure_address;

typedef int64_t(*visitgco_t)(uint64_t rl, void* ctx, void* func);
visitgco_t* rbx_visitgco = (visitgco_t*)&visitgco_address;

typedef uint64_t(* gettable_t)(uint64_t rl, roblox_structs::TValue* arg2, uint64_t key, roblox_structs::TValue* val, uint64_t arg5);
gettable_t* rbx_gettable = (gettable_t*)&gettable_address;

//typedef uint64_t(* getthread_t)(int* type, int num);
//getthread_t* rbx_getthread = (getthread_t*)&getthread_address;

//typedef uint64_t(* newproto_t)(uint64_t rl);
//newproto_t* rbx_newproto = (newproto_t*)&newproto_address;

std::string skidded_gen_random(const int len) {
    static const char alphanum[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
    std::string tmp_s;
    tmp_s.reserve(len);

    for (int i = 0; i < len; ++i) {
        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
    }
    
    return tmp_s;
}

void aby_pushcclosure(uint64_t rl, int(* function)(uint64_t), const char* name) {
    (*rbx_pushcclosure)(rl, function, name, 0, 0);
}

void rbx_register(uint64_t rl, int(* function)(uint64_t), const char* name) {
    (*rbx_pushcclosure)(rl, function, "Abyss", 0, 0);
    (*rbx_setfield)(rl, LUA_GLOBALSINDEX, name);
}

void rbx_pushstring(uint64_t rl, const std::string& str) {
    (*rbx_pushlstring)(rl, str.c_str(), str.size());
}

void serialize_proto(roblox_structs::Proto* proto, uint64_t newproto) {
    mach_vm_protect(mach_task_self(), newproto, 0x88, FALSE, VM_PROT_ALL);

    *(uint64_t*)(newproto + 0x8) = (uint64_t)proto->k + (newproto + 0x8);
    *(int*)(newproto + 0x60) = proto->sizek;
    *(uint64_t*)(newproto + 0x20) = (uint64_t)proto->p - (newproto + 0x20);
    *(int*)(newproto + 0x78) = proto->sizep;

    *(uint64_t*)(newproto + 0x30) = (uint64_t)proto->code ^ (newproto + 0x30);
    *(int*)(newproto + 0x64) = proto->sizecode;
    *(int*)(newproto + 0x70) = proto->sizeupvalues;
    *(uint8_t*)(newproto + 0x87) = proto->nups;
    *(uint64_t*)(newproto + 0x38) = (uint64_t)proto->upvalues - (newproto + 0x38);
    
    *(uint8_t*)(newproto + 0x86) = proto->maxstacksize;
    *(int*)(newproto + 0x7C) = proto->sizelineinfo;
    *(int*)(newproto + 0x68) = proto->linegaplog2;
    *(uint64_t*)(newproto + 0x10) = (newproto + 0x10) - (uint64_t)proto->lineinfo;
    *(uint64_t*)(newproto + 0x18) = (newproto + 0x18) + (uint64_t)proto->abslineinfo;

    *(int*)(newproto + 0x6C) = proto->sizelocvars;
    *(uint64_t*)(newproto + 0x40) = proto->locvars ^ (newproto + 0x40);
}

roblox_structs::Proto* deserialize_proto(uint64_t proto) {
    auto deserialized_proto = new roblox_structs::Proto;

    deserialized_proto->k = (roblox_structs::TValue*)(*(uint64_t*)(proto + 0x8) - (proto + 0x8));
    deserialized_proto->sizek = *(int*)(proto + 0x60);
    deserialized_proto->p = (roblox_structs::Proto**)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
    deserialized_proto->sizep = *(int*)(proto + 0x78);
    deserialized_proto->code = (uint32_t*)(*(uint64_t*)(proto + 0x30) ^ (proto + 0x30));
    deserialized_proto->sizecode = *(int*)(proto + 0x64);
    deserialized_proto->sizeupvalues = *(int*)(proto + 0x70);
    deserialized_proto->nups = *(uint8_t*)(proto + 0x87);
    deserialized_proto->upvalues = *(uint64_t*)(proto + 0x38) + (proto + 0x38);
    deserialized_proto->maxstacksize = *(uint8_t*)(proto + 0x86);
    deserialized_proto->sizelineinfo = *(int*)(proto + 0x7C);
    deserialized_proto->linegaplog2 = *(int*)(proto + 0x68);
    deserialized_proto->lineinfo = (uint8_t*)((proto + 0x10) - *(uint64_t*)(proto + 0x10));
    deserialized_proto->abslineinfo = (int*)(*(uint64_t*)(proto + 0x18) - (proto + 0x18));
    deserialized_proto->sizelocvars = *(int*)(proto + 0x6C);
    deserialized_proto->locvars = *(uint64_t*)(proto + 0x40) ^ (proto + 0x40);

    return deserialized_proto;
}

uint64_t filter_ptr_encryption(uint64_t ptr, ENC_TYPE type, bool enc_ptr = false) {
    uint64_t enc_data = *(uint64_t*)ptr;
    
    switch (type) {
        case ENC_ADD:
            return enc_ptr ? enc_data - ptr : enc_data + ptr;
        case ENC_XOR:
            return enc_data ^ ptr;
        case ENC_SUBPTR:
            return enc_ptr ? enc_data + ptr : enc_data - ptr;
        case ENC_SUBVAL:
            return enc_ptr ? ptr - enc_data : ptr - enc_data;
        default:
            return enc_data;
    }
}

uint64_t rbx_index2addr(uint64_t rl, int idx) {
    if (idx > 0) {
        return *(uint64_t*)(rl + offsets::state_base) + (idx - 1) * 0x10;
    } else if (idx > LUA_REGISTRYINDEX) {
        return *(uint64_t*)(rl + offsets::state_top) + idx * 0x10;
    } else {
        return (*rbx_pseudo2addr)(rl, idx);
    }
}

double rbx_tonumber(uint64_t rl, int idx) {
    auto value = (roblox_structs::TValue*)rbx_index2addr(rl, idx);
    return value->value.n;
}

int rbx_tointeger(uint64_t rl, int idx, int none = 0) {
    return static_cast<int>(rbx_tonumber(rl, idx));
}

int rbx_toboolean(uint64_t rl, int idx) {
    auto val = (roblox_structs::TValue*)rbx_index2addr(rl, idx);
    return val->value.b;
}

uint64_t rbx_touserdata(uint64_t rl, int idx) {
    auto udata = *(roblox_structs::Udata**)rbx_index2addr(rl, idx);
    return (uint64_t)&udata->data;
}

int rbx_ref(uint64_t rl, int idx) {
    (*rbx_pushvalue)(rl, idx);
    (*rbx_pushvalue)(rl, LUA_REGISTRYINDEX);

    auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    int tableidx = (*rbx_getnum)(tval->value.gcobject) + 1;

    (*rbx_pushvalue)(rl, -2);
    (*rbx_rawseti)(rl, -2, tableidx);
    rbx_pop(rl, 2);

    return tableidx;
}

int rbx_getref(uint64_t rl, int tableidx) {
    (*rbx_rawgeti)(rl, LUA_REGISTRYINDEX, tableidx);
    return tableidx;
}

int rbx_unref(uint64_t rl, int tableidx) {
    uint64_t th = (*rbx_newthread)(rl);
    (*rbx_getfield)(th, LUA_GLOBALSINDEX, "table");
    (*rbx_getfield)(th, -1, "remove");

    (*rbx_insert)(rl, -2);
    rbx_pop(rl, 1);

    (*rbx_rawgeti)(th, LUA_REGISTRYINDEX, tableidx);
    (*rbx_pushnumber)(th, tableidx);

    (*rbx_pcall)(th);
    return tableidx;
}

int lua_ref(uint64_t rl) {
    (*rbx_pushvalue)(rl, LUA_REGISTRYINDEX);
    auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    int tableidx = (*rbx_getnum)(tval->value.gcobject) + 1;

    (*rbx_pushvalue)(rl, -2);
    (*rbx_rawseti)(rl, -2, tableidx);
    rbx_pop(rl, 1);
    return tableidx;
}

__int128* rbx_getidentity(uint64_t rl) {
    return (__int128*)(*(uint64_t*)(rl + 0x78) + 0x30);
}

bool ptr_is_valid(mach_vm_address_t address, vm_prot_t needs_access) {
    mach_vm_size_t size = 0;
    mach_port_t object_name;

    vm_region_basic_info_data_64_t info;
    mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;
    kern_return_t ret = mach_vm_region(mach_task_self(), &address, &size, VM_REGION_BASIC_INFO_64, (vm_region_info_t)&info, &count, &object_name);

    if (ret != KERN_SUCCESS) return false;
    return (info.protection & needs_access) == needs_access;
}

void new_context_hook() {
    mach_vm_protect(mach_task_self(), context_address, 2, FALSE, VM_PROT_ALL);
    uint8_t new_bytes[2] = { 0xC2, 0x10 };
    memcpy((void*)context_address, new_bytes, 2);
    mach_vm_protect(mach_task_self(), context_address, 2, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
}

const char* rbx_tolstring(uint64_t rl, int idx, size_t* size = nullptr) {
    return (*rbx_tolstring2)(rl, idx, size);
    
    /*
    auto val = (roblox_structs::TValue*)rbx_index2addr(rl, idx);
    const char* sval = (const char*)(val->value.gcobject + 0x18);
    if (size) { *size = strlen(sval); }
    return sval; */
}

void multi_service() {
    while (true) {
        sem_unlink("/RobloxPlayerUniq");
        usleep(200000);
    }
}

bool print_pointer_stub(uint64_t ptr, int indentation) {
    if (indentation > 5) {
        return false;
    }

    std::string indent = "";
    for (int i = 0; i < indentation; i++) {
        indent.append("  ");
    }

    auto cl = (roblox_structs::Closure*)ptr;
    if (cl->tt == LUA_TFUNCTION) {
        if (!cl->isC) {
            std::cout << indent << "[Abyss] Closure 0x" << ptr << "\n";
            //uint64_t proto = (uint64_t)&cl->l.p + cl->l.p;
            //uint64_t debugname = (proto + 0x48) ^ *(uint64_t*)(proto + 0x48);
            //if (debugname) {
            //    const char* fname = (const char*)(debugname + 0x18);
            //    std::cout << indent << "Name: " << fname << "\n";
            //} else {
            //    std::cout << indent << "Name: Unknown\n";
            //}
            
            return true;
        }
    }

    bool positive_result = false;
    for (int i = 0; i < 64; i += 8) {
        uint64_t current_ptr = *(uint64_t*)(ptr + i);
        if (ptr_is_valid(current_ptr, VM_PROT_DEFAULT)) {
            if (print_pointer_stub(current_ptr, indentation + 1)) {
                std::cout << indent << "-> 0x" << ptr << " + 0x" << i << "\n";
                positive_result = true;
            }
        }
    }

    return positive_result;
}

void scan_pointer(uint64_t ptr) {
    std::cout << "[Abyss] Beginning Pointer Scan...\n";
    print_pointer_stub(ptr, 0);
}

uint64_t rbx_getstacktop(uint64_t rl) {
    return *(uint64_t*)(rl + offsets::state_top);
}

void rbx_incrementtop(uint64_t rl) {
    *(uint64_t*)(rl + offsets::state_top) += 0x10;
}

void rbx_decrementtop(uint64_t rl) {
    *(uint64_t*)(rl + offsets::state_top) -= 0x10;
}

void rbx_setsvalue(uint64_t address, uint64_t tvalue) {
    memcpy((void*)address, (void*)tvalue, 0x10);
}

void rbx_setidentity(uint64_t rl, __int128 identity) {
    *rbx_getidentity(rl) = identity;
}

void rbx_pushnil(uint64_t rl) {
    **(uint64_t**)(rl + offsets::state_top) = 0;
    *(int*)(*(uint64_t*)(rl + offsets::state_top) + 0xC) = LUA_TNIL;
    *(uint64_t*)(rl + offsets::state_top) += 0x10;
}

int rbx_gettop(uint64_t rl) {
    return static_cast<int>((rbx_getstacktop(rl) - rbx_index2addr(rl, 1)) / 16);
}

void rbx_xmove(uint64_t from, uint64_t to, int n) {
    if (from == to) return;
    auto ttop = *(uint64_t*)(to + offsets::state_top);
    auto ftop = *(uint64_t*)(from + offsets::state_top) - n * 0x10;

    for (int i = 0; i < n; i++) {
        auto elem1 = (roblox_structs::TValue*)(ttop + i * 0x10);
        auto elem2 = (roblox_structs::TValue*)(ftop + i * 0x10);
        *elem1 = *elem2;
    }

    *(uint64_t*)(from + offsets::state_top) = ftop - n * 0x10;
    *(uint64_t*)(to + offsets::state_top) = ttop + n * 0x10;
    return;
}

void rbx_printstack(uint64_t rl) {
    for (int i = 0; i < rbx_gettop(rl); i++) {
        auto elem = (roblox_structs::TValue*)(*(uint64_t*)(rl + offsets::state_base) + i * 0x10);
        std::cout << "[Stack] 0x" << elem->tt << "\n";
    }
}

std::unordered_map<uint64_t, std::string> yield_map;

#define LUA_YIELD 1
int rbx_yield(uint64_t rl, int nresults) {
    if (yield_map.find(rl) == yield_map.end()) {
        (*rbx_pushvalue)(rl, LUA_REGISTRYINDEX);
        auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
        top->value.gcobject = rl;
        top->tt = LUA_TTHREAD;
        rbx_incrementtop(rl);

        std::string thread_ref = skidded_gen_random(16);
        (*rbx_setfield)(rl, -2, thread_ref.c_str());
        yield_map[rl] = thread_ref;
        rbx_pop(rl, 1);
    }

    *(int*)(*(uint64_t*)(rl + offsets::state_callinfo) + 0x24) |= 1;
    *(uint64_t*)(rl + offsets::state_base) = *(uint64_t*)(rl + offsets::state_top) - (0x10 * nresults);
    *(int8_t*)(rl + 3) = LUA_YIELD;
    return -1;
}

int rbx_continue(uint64_t rl, int nresults) {
    if (!roblox_thread || teleport_event) {
        return 0;
    }

    uint64_t new_state = (*rbx_newthread)(rl);
    (*rbx_getfield)(new_state, LUA_GLOBALSINDEX, "task");
    (*rbx_getfield)(new_state, -1, "defer");
    (*rbx_insert)(new_state, -2);
    rbx_pop(new_state, 1);
    
    auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
    top->value.gcobject = rl;
    top->tt = LUA_TTHREAD;
    rbx_incrementtop(rl);

    rbx_xmove(rl, new_state, 1);
    for (int i = nresults; i >= 1; i--) {
        (*rbx_pushvalue)(rl, -i);
        rbx_xmove(rl, new_state, 1);
    }

    int result = (*rbx_pcall)(new_state);
    (*rbx_settop)(new_state, 0);
    return result;
}

void rbx_pushboolean(uint64_t rl, bool value) {
    auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
    top->tt = LUA_TBOOLEAN;
    top->value.b = value;

    rbx_incrementtop(rl);
}

int rbx_gettype(uint64_t rl, int idx) {
    if (idx > 0) {
        return *(int*)(*(uint64_t*)(rl + offsets::state_base) + 0xC + (idx - 1) * 0x10);
    } else {
        return *(int*)(*(uint64_t*)(rl + offsets::state_top) + idx * 0x10 + 0xC);
    }
}

/*
int rbx_getinfo(uint64_t rl, const char* what, uint64_t func = 0, int level = 0) {
    roblox_structs::Closure* cl;
    if (func) {
        cl = (roblox_structs::Closure*)func;
    } else {
        if (level < 0) {
            auto fval = (roblox_structs::TValue*)(rbx_getstacktop(rl) - level * 0x10);
            cl = (roblox_structs::Closure*)fval->value.gcobject;            
        } else {
            uint64_t ci = *(uint64_t*)(rl + 0x8);
            ci -= level * 0x28;
            cl = *(roblox_structs::Closure**)(ci + 0x8);
        }
    }

    std::cout << "[Abyss] Successfully got closure: 0x" << (uint64_t)cl << "\n";
    return 0;
}

*/

void setup_discord_rpc() {
    DiscordEventHandlers handler;
    memset(&handler, 0, sizeof(handler));
	Discord_Initialize("1232663666415894600", &handler, 1, NULL);

    DiscordRichPresence discord_presence;
    memset(&discord_presence, 0, sizeof(discord_presence));
    discord_presence.state = "Breaking Roblox's Security";
    discord_presence.smallImageKey = "abyssdesigner";
    discord_presence.startTimestamp = time(0);
    Discord_UpdatePresence(&discord_presence);
}

void skiddedReplaceAll(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
}

void sanitiseFileInput(std::string& ref) {
    skiddedReplaceAll(ref, "../", "");
    skiddedReplaceAll(ref, "..\\", "");
    skiddedReplaceAll(ref, "\\", "/");
}

uint64_t filter_globals(uint64_t rl) {
    (*rbx_pushvalue)(rl, LUA_GLOBALSINDEX);
    auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    uint64_t new_gt = (*rbx_createtable)(rl, 0, (*rbx_getnum)(tval->value.gcobject));
    uint64_t old_gt = tval->value.gcobject;
    (*rbx_insert)(rl, -2);

    rbx_pushnil(rl);
    while ((*rbx_next)(rl, -2)) {
        const char* key = rbx_tolstring(rl, -2, nullptr);
        if (!key) { rbx_pop(rl, 1); continue; }

        auto value = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        (*rbx_setfield)(rl, -4, key);
    }

    for (int i = 0; i < 0x100; i++) {
        if (*(uint64_t*)(rl + i) == old_gt) {
            *(uint64_t*)(rl + i) = new_gt;
            std::cout << "[Abyss] Updated Global Table at [0x" << i << "]\n";
            offsets::state_env = i;
            break;
        }
    }

    exploit_env = new_gt;
    (*rbx_createtable)(rl, 0, 0);
    (*rbx_setfield)(rl, -3, "_G");

    rbx_pop(rl, 2);
    return old_gt;
}

bool rbx_isnil(uint64_t rl, int idx) {
    return rbx_gettype(rl, idx) == LUA_TNIL;
}

void rbx_assert(uint64_t rl, bool result, std::string name, int type) {
    if (rbx_isnil(rl, -1) || rbx_gettype(rl, -1) != type) {
        (*rbx_error)(std::string("Invalid value for " + name).c_str(), 0);
    }
}

void rbx_setreadonly(uint64_t rl, int idx, bool readonly) {
    uint64_t table = *(uint64_t*)rbx_index2addr(rl, idx);
    *(int8_t*)(table + offsets::table::isreadonly_offset) = readonly;
}

void rbx_registerlib(uint64_t rl, std::string libname, std::unordered_map<std::string, int(*)(uint64_t)> functions) {
    (*rbx_getfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    if (rbx_isnil(rl, -1)) {
        rbx_pop(rl, 1);
        (*rbx_createtable)(rl, 0, functions.size());
        for (auto pair : functions) {
            (*rbx_pushcclosure)(rl, pair.second, "Abyss", 0, 0);
            (*rbx_setfield)(rl, -2, pair.first.c_str());
        }

        (*rbx_setfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    } else {
        auto old_lib = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        uint64_t new_lib = (*rbx_createtable)(rl, 0, (*rbx_getnum)(old_lib->value.gcobject) + functions.size());
        (*rbx_insert)(rl, -2);

        rbx_pushnil(rl);
        while ((*rbx_next)(rl, -2)) {
            const char* key = rbx_tolstring(rl, -2, nullptr);
            (*rbx_setfield)(rl, -4, key);
        }

        rbx_pop(rl, 1);
        for (auto pair : functions) {
            (*rbx_pushcclosure)(rl, pair.second, "Abyss", 0, 0);
            (*rbx_setfield)(rl, -2, pair.first.c_str());
        }

        (*rbx_setfield)(rl, LUA_GLOBALSINDEX, libname.c_str());
    }
}

namespace settings {
    struct setting_obj_t {
        std::string key;
        std::string value;
    };

    bool refreshed = false;
    std::unordered_map<std::string, bool> bool_settings;
    typedef std::unordered_map<std::string, bool> settings_t;

    bool get_boolean(std::string name) {
        return bool_settings[name];
    }

    void add_boolean(std::string key, std::string val) {
        bool_settings[key] = val == "false" ? false : true;
    }

    void handle_setting(std::string key, std::string value) {
        if (key == "debugLibrary" && roblox_thread) {
            if (value == "true") {
                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "_WebSocket");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_pushvalue)(roblox_thread, -1);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "WebSocket");
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "websocket");
                    rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_WebSocket");
                } else { rbx_pop(roblox_thread, 1); }
            } else {
                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "WebSocket");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_WebSocket");
                    rbx_pushnil(roblox_thread); rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "WebSocket");
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "websocket");
                } else { rbx_pop(roblox_thread, 1); }
            }
        }

        if (key == "discordRpc" && boosting_status) {
            if (value == "false") {
                Discord_ClearPresence();
            }
        }

        if (key == "httpTraffic" && roblox_thread) {
            if (value == "true") {
                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "_httpget_async");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "httpget_async");
                    rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_httpget_async");
                } else { rbx_pop(roblox_thread, 1); }

                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "_http_request");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "http_request");
                    rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_http_request");
                } else { rbx_pop(roblox_thread, 1); }
            } else {
                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "httpget_async");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_httpget_async");
                    rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "httpget_async");
                } else { rbx_pop(roblox_thread, 1); }

                (*rbx_getfield)(roblox_thread, LUA_GLOBALSINDEX, "http_request");
                if (!rbx_isnil(roblox_thread, -1)) {
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "_http_request");
                    rbx_pushnil(roblox_thread);
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "http_request");
                } else { rbx_pop(roblox_thread, 1); }
            }
        }

        if (key == "serverTeleports") {
            prevent_server_teleports = value == "false" ? true : false;
        }

        if (key == "dumpScripts") {
            deserialize_dumpscripts = value == "false" ? false : true;
        }

        if (key == "logHttp") {
            //deserialize_printscripts = value == "false" ? false : true;
            macsploit_safemode = value == "false" ? true : false;
        }

        if (key == "autoInject") {
            if (*(uint64_t*)taskscheduler_address == 0) {
                add_boolean(key, value);
                return;
            }

            if (value == "true") {
                *(double*)(*(uint64_t*)taskscheduler_address + 0x138) = 1 / 400.0;
                add_boolean(key, value);
                return;
            }

            *(double*)(*(uint64_t*)taskscheduler_address + 0x138) = 1 / 60.0;
        }

        if (key == "multiInstance") {
            if (value == "true") {
                script_author = std::string("=script ." + hidden_seed).c_str();
                add_boolean(key, value);
                return;
            }

            script_author = default_author;
        }

        if (key == "executeInstances" && value == "true") {
            spoofed_hwid = skidded_gen_random(37);
        }

        add_boolean(key, value);
    }

    void reload() {
        for (auto pair : bool_settings) {
            handle_setting(pair.first, pair.second ? "true" : "false");
        }
    }

    void load_settings() {
        std::string settings_path = std::string(getenv("HOME")) + "/Downloads/ms-settings";
        std::ifstream file(settings_path);
        if (!file.good()) return;

        std::string chunk;
        while (getline(file, chunk)) {
            if (chunk.size() < 2) continue;
            std::istringstream data(chunk);
            std::string key; std::getline(data, key, ' ');
            std::string value; std::getline(data, value, ' ');
            handle_setting(key, value);
        }
    }

    void reload_config() {
        std::unordered_map<std::string, bool> bool_settings {
            { "autoExecute", true },
            { "httpTraffic", true },
            { "placeRestrictions", true },
            { "settingsControl", true },
            { "executeInstances", false },
            { "autoInject", true },
            { "compatibilityMode", false },
            { "debugLibrary", false },
            { "norbUnc", true },
            { "resumeHandle", false },
            { "fileSystem", true },
            { "sandbox", false },
            { "multiInstance", false },
            { "robloxRpc", true },
            { "discordRpc", true },
            { "macsploit", true }
        };

        settings::bool_settings = bool_settings;
        settings::load_settings();
        std::cout << "[Abyss] Loaded Settings Config.\n";
    }
}

std::string fetch_fingerprint() {
    uuid_t hwid_uuid; char hwid_str[37]; SHA1 checksum;
    struct timespec timeout{ NULL, NULL };
    gethostuuid((unsigned char*)&hwid_uuid, &timeout);
    uuid_unparse(hwid_uuid, hwid_str);

    checksum.update(std::string(hwid_str));
    return checksum.final();
}

std::string parsed_fingerprint() {
    if (settings::get_boolean("executeInstances")) {
        SHA1 checksum; checksum.update(spoofed_hwid);
        std::string hwid_spoof = checksum.final();
        return hwid_spoof + "5f4d53"; //_MS
    }

    return fetch_fingerprint() + "5f4d53"; //_MS
}

/*
void exec_log(std::string data) {
    CURL* curl = curl_easy_init();
    curl_easy_setopt(curl, CURLOPT_URL, "http://203.219.222.96:8993/");
    struct curl_slist* curl_headers = curl_slist_append(NULL, std::string("Authentication: " + fetch_fingerprint()).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, curl_headers);
    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());
    curl_easy_perform(curl);
    curl_easy_cleanup(curl);
}

void log_exec(std::string data) {
    std::thread(exec_log, data).detach();
}
*/

bool execute_script(uint64_t rl, std::string script) {
    std::string script_bytecode = Luau::compile(script);

    if ((*rbx_deserialize)(rl, script_author.c_str(), script_bytecode.c_str(), script_bytecode.size(), 0) != 0) {
        (*rbx_print)(3, rbx_tolstring(rl, -1, nullptr));
        (*rbx_settop)(rl, 0);
        return false;
    }

    (*rbx_spawn)(rl);
    (*rbx_settop)(rl, 0);
    return true;
}

void vformatAppend(std::string& ret, const char* fmt, va_list args)
{
    va_list argscopy;
    va_copy(argscopy, args);
#ifdef _MSC_VER
    int actualSize = _vscprintf(fmt, argscopy);
#else
    int actualSize = vsnprintf(NULL, 0, fmt, argscopy);
#endif
    va_end(argscopy);

    if (actualSize <= 0)
        return;

    size_t sz = ret.size();
    ret.resize(sz + actualSize);
    vsnprintf(&ret[0] + sz, actualSize + 1, fmt, args);
}

void formatAppend(std::string& str, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vformatAppend(str, fmt, args);
    va_end(args);
}

namespace LuauBytecode {
    enum LuauOpcode
    {
        // NOP: noop
        LOP_NOP,

        // BREAK: debugger break
        LOP_BREAK,

        // LOADNIL: sets register to nil
        // A: target register
        LOP_LOADNIL,

        // LOADB: sets register to boolean and jumps to a given short offset (used to compile comparison results into a boolean)
        // A: target register
        // B: value (0/1)
        // C: jump offset
        LOP_LOADB,

        // LOADN: sets register to a number literal
        // A: target register
        // D: value (-32768..32767)
        LOP_LOADN,

        // LOADK: sets register to an entry from the constant table from the proto (number/string)
        // A: target register
        // D: constant table index (0..32767)
        LOP_LOADK,

        // MOVE: move (copy) value from one register to another
        // A: target register
        // B: source register
        LOP_MOVE,

        // GETGLOBAL: load value from global table using constant string as a key
        // A: target register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_GETGLOBAL,

        // SETGLOBAL: set value in global table using constant string as a key
        // A: source register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_SETGLOBAL,

        // GETUPVAL: load upvalue from the upvalue table for the current function
        // A: target register
        // B: upvalue index (0..255)
        LOP_GETUPVAL,

        // SETUPVAL: store value into the upvalue table for the current function
        // A: target register
        // B: upvalue index (0..255)
        LOP_SETUPVAL,

        // CLOSEUPVALS: close (migrate to heap) all upvalues that were captured for registers >= target
        // A: target register
        LOP_CLOSEUPVALS,

        // GETIMPORT: load imported global table global from the constant table
        // A: target register
        // D: constant table index (0..32767); we assume that imports are loaded into the constant table
        // AUX: 3 10-bit indices of constant strings that, combined, constitute an import path; length of the path is set by the top 2 bits (1,2,3)
        LOP_GETIMPORT,

        // GETTABLE: load value from table into target register using key from register
        // A: target register
        // B: table register
        // C: index register
        LOP_GETTABLE,

        // SETTABLE: store source register into table using key from register
        // A: source register
        // B: table register
        // C: index register
        LOP_SETTABLE,

        // GETTABLEKS: load value from table into target register using constant string as a key
        // A: target register
        // B: table register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_GETTABLEKS,

        // SETTABLEKS: store source register into table using constant string as a key
        // A: source register
        // B: table register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        LOP_SETTABLEKS,

        // GETTABLEN: load value from table into target register using small integer index as a key
        // A: target register
        // B: table register
        // C: index-1 (index is 1..256)
        LOP_GETTABLEN,

        // SETTABLEN: store source register into table using small integer index as a key
        // A: source register
        // B: table register
        // C: index-1 (index is 1..256)
        LOP_SETTABLEN,

        // NEWCLOSURE: create closure from a child proto; followed by a CAPTURE instruction for each upvalue
        // A: target register
        // D: child proto index (0..32767)
        LOP_NEWCLOSURE,

        // NAMECALL: prepare to call specified method by name by loading function from source register using constant index into target register and copying source register into target register + 1
        // A: target register
        // B: source register
        // C: predicted slot index (based on hash)
        // AUX: constant table index
        // Note that this instruction must be followed directly by CALL; it prepares the arguments
        // This instruction is roughly equivalent to GETTABLEKS + MOVE pair, but we need a special instruction to support custom __namecall metamethod
        LOP_NAMECALL,

        // CALL: call specified function
        // A: register where the function object lives, followed by arguments; results are placed starting from the same register
        // B: argument count + 1, or 0 to preserve all arguments up to top (MULTRET)
        // C: result count + 1, or 0 to preserve all values and adjust top (MULTRET)
        LOP_CALL,

        // RETURN: returns specified values from the function
        // A: register where the returned values start
        // B: number of returned values + 1, or 0 to return all values up to top (MULTRET)
        LOP_RETURN,

        // JUMP: jumps to target offset
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMP,

        // JUMPBACK: jumps to target offset; this is equivalent to JUMP but is used as a safepoint to be able to interrupt while/repeat loops
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPBACK,

        // JUMPIF: jumps to target offset if register is not nil/false
        // A: source register
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPIF,

        // JUMPIFNOT: jumps to target offset if register is nil/false
        // A: source register
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        LOP_JUMPIFNOT,

        // JUMPIFEQ, JUMPIFLE, JUMPIFLT, JUMPIFNOTEQ, JUMPIFNOTLE, JUMPIFNOTLT: jumps to target offset if the comparison is true (or false, for NOT variants)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: source register 2
        LOP_JUMPIFEQ,
        LOP_JUMPIFLE,
        LOP_JUMPIFLT,
        LOP_JUMPIFNOTEQ,
        LOP_JUMPIFNOTLE,
        LOP_JUMPIFNOTLT,

        // ADD, SUB, MUL, DIV, MOD, POW: compute arithmetic operation between two source registers and put the result into target register
        // A: target register
        // B: source register 1
        // C: source register 2
        LOP_ADD,
        LOP_SUB,
        LOP_MUL,
        LOP_DIV,
        LOP_MOD,
        LOP_POW,

        // ADDK, SUBK, MULK, DIVK, MODK, POWK: compute arithmetic operation between the source register and a constant and put the result into target register
        // A: target register
        // B: source register
        // C: constant table index (0..255)
        LOP_ADDK,
        LOP_SUBK,
        LOP_MULK,
        LOP_DIVK,
        LOP_MODK,
        LOP_POWK,

        // AND, OR: perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register
        // A: target register
        // B: source register 1
        // C: source register 2
        LOP_AND,
        LOP_OR,

        // ANDK, ORK: perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register
        // A: target register
        // B: source register
        // C: constant table index (0..255)
        LOP_ANDK,
        LOP_ORK,

        // CONCAT: concatenate all strings between B and C (inclusive) and put the result into A
        // A: target register
        // B: source register start
        // C: source register end
        LOP_CONCAT,

        // NOT, MINUS, LENGTH: compute unary operation for source register and put the result into target register
        // A: target register
        // B: source register
        LOP_NOT,
        LOP_MINUS,
        LOP_LENGTH,

        // NEWTABLE: create table in target register
        // A: target register
        // B: table size, stored as 0 for v=0 and ceil(log2(v))+1 for v!=0
        // AUX: array size
        LOP_NEWTABLE,

        // DUPTABLE: duplicate table using the constant table template to target register
        // A: target register
        // D: constant table index (0..32767)
        LOP_DUPTABLE,

        // SETLIST: set a list of values to table in target register
        // A: target register
        // B: source register start
        // C: value count + 1, or 0 to use all values up to top (MULTRET)
        // AUX: table index to start from
        LOP_SETLIST,

        // FORNPREP: prepare a numeric for loop, jump over the loop if first iteration doesn't need to run
        // A: target register; numeric for loops assume a register layout [limit, step, index, variable]
        // D: jump offset (-32768..32767)
        // limit/step are immutable, index isn't visible to user code since it's copied into variable
        LOP_FORNPREP,

        // FORNLOOP: adjust loop variables for one iteration, jump back to the loop header if loop needs to continue
        // A: target register; see FORNPREP for register layout
        // D: jump offset (-32768..32767)
        LOP_FORNLOOP,

        // FORGLOOP: adjust loop variables for one iteration of a generic for loop, jump back to the loop header if loop needs to continue
        // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
        // D: jump offset (-32768..32767)
        // AUX: variable count (1..255) in the low 8 bits, high bit indicates whether to use ipairs-style traversal in the fast path
        // loop variables are adjusted by calling generator(state, index) and expecting it to return a tuple that's copied to the user variables
        // the first variable is then copied into index; generator/state are immutable, index isn't visible to user code
        LOP_FORGLOOP,

        // FORGPREP_INEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_inext, and jump to FORGLOOP
        // A: target register (see FORGLOOP for register layout)
        LOP_FORGPREP_INEXT,

        // removed in v3
        LOP_DEP_FORGLOOP_INEXT,

        // FORGPREP_NEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_next, and jump to FORGLOOP
        // A: target register (see FORGLOOP for register layout)
        LOP_FORGPREP_NEXT,

        // removed in v3
        LOP_DEP_FORGLOOP_NEXT,

        // GETVARARGS: copy variables into the target register from vararg storage for current function
        // A: target register
        // B: variable count + 1, or 0 to copy all variables and adjust top (MULTRET)
        LOP_GETVARARGS,

        // DUPCLOSURE: create closure from a pre-created function object (reusing it unless environments diverge)
        // A: target register
        // D: constant table index (0..32767)
        LOP_DUPCLOSURE,

        // PREPVARARGS: prepare stack for variadic functions so that GETVARARGS works correctly
        // A: number of fixed arguments
        LOP_PREPVARARGS,

        // LOADKX: sets register to an entry from the constant table from the proto (number/string)
        // A: target register
        // AUX: constant table index
        LOP_LOADKX,

        // JUMPX: jumps to the target offset; like JUMPBACK, supports interruption
        // E: jump offset (-2^23..2^23; 0 means "next instruction" aka "don't jump")
        LOP_JUMPX,

        // FASTCALL: perform a fast call of a built-in function
        // A: builtin function id (see LuauBuiltinFunction)
        // C: jump offset to get to following CALL
        // FASTCALL is followed by one of (GETIMPORT, MOVE, GETUPVAL) instructions and by CALL instruction
        // This is necessary so that if FASTCALL can't perform the call inline, it can continue normal execution
        // If FASTCALL *can* perform the call, it jumps over the instructions *and* over the next CALL
        // Note that FASTCALL will read the actual call arguments, such as argument/result registers and counts, from the CALL instruction
        LOP_FASTCALL,

        // COVERAGE: update coverage information stored in the instruction
        // E: hit count for the instruction (0..2^23-1)
        // The hit count is incremented by VM every time the instruction is executed, and saturates at 2^23-1
        LOP_COVERAGE,

        // CAPTURE: capture a local or an upvalue as an upvalue into a newly created closure; only valid after NEWCLOSURE
        // A: capture type, see LuauCaptureType
        // B: source register (for VAL/REF) or upvalue index (for UPVAL/UPREF)
        LOP_CAPTURE,

        // removed in v3
        LOP_DEP_JUMPIFEQK,
        LOP_DEP_JUMPIFNOTEQK,

        // FASTCALL1: perform a fast call of a built-in function using 1 register argument
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        LOP_FASTCALL1,

        // FASTCALL2: perform a fast call of a built-in function using 2 register arguments
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        // AUX: source register 2 in least-significant byte
        LOP_FASTCALL2,

        // FASTCALL2K: perform a fast call of a built-in function using 1 register argument and 1 constant argument
        // A: builtin function id (see LuauBuiltinFunction)
        // B: source argument register
        // C: jump offset to get to following CALL
        // AUX: constant index
        LOP_FASTCALL2K,

        // FORGPREP: prepare loop variables for a generic for loop, jump to the loop backedge unconditionally
        // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
        // D: jump offset (-32768..32767)
        LOP_FORGPREP,

        // JUMPXEQKNIL, JUMPXEQKB: jumps to target offset if the comparison with constant is true (or false, see AUX)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit
        LOP_JUMPXEQKNIL,
        LOP_JUMPXEQKB,

        // JUMPXEQKN, JUMPXEQKS: jumps to target offset if the comparison with constant is true (or false, see AUX)
        // A: source register 1
        // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
        // AUX: constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit
        LOP_JUMPXEQKN,
        LOP_JUMPXEQKS,

        // Enum entry for number of opcodes, not a valid opcode by itself!
        LOP__COUNT
    };
}

namespace hook {
    char deserialize_bytes[12] = "\x55\x48\x89\xe5\x41\x57\xe9\x11\x11\x11\x11";
    char create_job_bytes[12] = "\x55\x48\x89\xe5\x41\x57\xe9\x11\x11\x11\x11";
    char connect_bytes[12] = "\x55\x48\x89\xe5\x41\x56\xe9\x11\x11\x11\x11";
    size_t hook_len = 11;

    static int getOpLength(LuauOpcode op)
    {
        switch (op)
        {
            case LOP_GETGLOBAL:
            case LOP_SETGLOBAL:
            case LOP_GETIMPORT:
            case LOP_GETTABLEKS:
            case LOP_SETTABLEKS:
            case LOP_NAMECALL:
            case LOP_JUMPIFEQ:
            case LOP_JUMPIFLE:
            case LOP_JUMPIFLT:
            case LOP_JUMPIFNOTEQ:
            case LOP_JUMPIFNOTLE:
            case LOP_JUMPIFNOTLT:
            case LOP_NEWTABLE:
            case LOP_SETLIST:
            case LOP_FORGLOOP:
            case LOP_LOADKX:
            case LOP_JUMPIFEQK:
            case LOP_JUMPIFNOTEQK:
            case LOP_FASTCALL2:
            case LOP_FASTCALL2K:
                return 2;

            default:
                return 1;
        }
    }

    std::string getConstant(uint64_t rl, int kv, uint64_t proto) {
        int sizek = *(int*)(proto + offsets::proto::sizek);
        if (kv > sizek || kv < 0) return "";

        uint64_t constant = (proto + offsets::proto::constants);
        uint64_t constants = filter_ptr_encryption(constant, CONSTANT_ENC);
        auto current_constant = (roblox_structs::TValue*)constants + kv;

        rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)current_constant);
        rbx_incrementtop(rl);

        const char* stringv = (*rbxl_tolstring)(rl, -1, NULL);
        rbx_pop(rl, 1);

        if (current_constant->tt == LUA_TSTRING) {
            std::string cnst = " (\"";
            cnst += stringv;
            cnst += "\")";
            return cnst;
        }

        std::string cnst = " (";
        cnst += stringv;
        cnst += ")";
        return cnst;
    }

    #define LUAU_INSN_A(insn) (((insn) >> 8) & 0xff)
    #define LUAU_INSN_B(insn) (((insn) >> 16) & 0xff)
    #define LUAU_INSN_C(insn) (((insn) >> 24) & 0xff)
    #define LUAU_INSN_OP(insn) ((insn) & 0xff)
    void dumpInstructionX(uint64_t rl, const uint32_t* code, std::string& result, uint64_t proto, roblox_structs::Closure* cl, int targetLabel) {
        uint32_t insn = *code++;
        uint8_t op = LUAU_INSN_OP(insn);
        uint8_t opdec = op * 203;

        switch (opdec)
        {
            case LOP_LOADNIL:
                formatAppend(result, "LOADNIL R%d\n", LUAU_INSN_A(insn));
                break;

            case LOP_LOADB:
                if (LUAU_INSN_C(insn))
                    formatAppend(result, "LOADB R%d %d +%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                else
                    formatAppend(result, "LOADB R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_LOADN:
                formatAppend(result, "LOADN R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn));
                break;

            case LOP_LOADK:
                formatAppend(result, "LOADK R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn), getConstant(rl, LUAU_INSN_D(insn), proto).c_str());
                break;

            case LOP_MOVE:
                formatAppend(result, "MOVE R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_GETGLOBAL: { int k = *code++;
                formatAppend(result, "GETGLOBAL R%d K%d%s\n", LUAU_INSN_A(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }
            case LOP_SETGLOBAL: { int k = *code++;
                formatAppend(result, "SETGLOBAL R%d K%d%s\n", LUAU_INSN_A(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }
            case LOP_GETUPVAL: {
                //int uv = LUAU_INSN_B(insn);
                //auto tval = cl->l.uprefs[uv];
                formatAppend(result, "GETUPVAL R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;
            }

            case LOP_SETUPVAL:
                formatAppend(result, "SETUPVAL R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_CLOSEUPVALS:
                formatAppend(result, "CLOSEUPVALS R%d\n", LUAU_INSN_A(insn));
                break;

            case LOP_GETIMPORT:
                formatAppend(result, "GETIMPORT R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn));
                code++; // AUX
                break;

            case LOP_GETTABLE:
                formatAppend(result, "GETTABLE R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_SETTABLE:
                formatAppend(result, "SETTABLE R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_GETTABLEKS: { int k = *code++;
                formatAppend(result, "GETTABLEKS R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }

            case LOP_SETTABLEKS: { int k = *code++;
                formatAppend(result, "SETTABLEKS R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }

            case LOP_GETTABLEN:
                formatAppend(result, "GETTABLEN R%d R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn) + 1);
                break;

            case LOP_SETTABLEN:
                formatAppend(result, "SETTABLEN R%d R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn) + 1);
                break;

            case LOP_NEWCLOSURE:
                formatAppend(result, "NEWCLOSURE R%d P%d\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn));
                break;

            case LOP_NAMECALL: { int k = *code++;
                formatAppend(result, "NAMECALL R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }
            case LOP_CALL:
                formatAppend(result, "CALL R%d %d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn) - 1, LUAU_INSN_C(insn) - 1);
                break;

            case LOP_RETURN:
                formatAppend(result, "RETURN R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn) - 1);
                break;

            case LOP_JUMP:
                formatAppend(result, "JUMP L%d\n", targetLabel);
                break;

            case LOP_JUMPIF:
                formatAppend(result, "JUMPIF R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_JUMPIFNOT:
                formatAppend(result, "JUMPIFNOT R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_JUMPIFEQ:
                formatAppend(result, "JUMPIFEQ R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFLE:
                formatAppend(result, "JUMPIFLE R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFLT:
                formatAppend(result, "JUMPIFLT R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFNOTEQ:
                formatAppend(result, "JUMPIFNOTEQ R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFNOTLE:
                formatAppend(result, "JUMPIFNOTLE R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFNOTLT:
                formatAppend(result, "JUMPIFNOTLT R%d R%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_ADD:
                formatAppend(result, "ADD R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_SUB:
                formatAppend(result, "SUB R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_MUL:
                formatAppend(result, "MUL R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_DIV:
                formatAppend(result, "DIV R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_MOD:
                formatAppend(result, "MOD R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_POW:
                formatAppend(result, "POW R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_ADDK:
                formatAppend(result, "ADDK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_SUBK:
                formatAppend(result, "SUBK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_MULK:
                formatAppend(result, "MULK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_DIVK:
                formatAppend(result, "DIVK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_MODK:
                formatAppend(result, "MODK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_POWK:
                formatAppend(result, "POWK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_AND:
                formatAppend(result, "AND R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_OR:
                formatAppend(result, "OR R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_ANDK:
                formatAppend(result, "ANDK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_ORK:
                formatAppend(result, "ORK R%d R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_CONCAT:
                formatAppend(result, "CONCAT R%d R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn));
                break;

            case LOP_NOT:
                formatAppend(result, "NOT R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_MINUS:
                formatAppend(result, "MINUS R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_LENGTH:
                formatAppend(result, "LENGTH R%d R%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn));
                break;

            case LOP_NEWTABLE:
                formatAppend(result, "NEWTABLE R%d %d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn) == 0 ? 0 : 1 << (LUAU_INSN_B(insn) - 1), *code++);
                break;

            case LOP_DUPTABLE:
                formatAppend(result, "DUPTABLE R%d %d%s\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn), getConstant(rl, LUAU_INSN_D(insn), proto).c_str());
                break;

            case LOP_SETLIST:
                formatAppend(result, "SETLIST R%d R%d %d [%d]\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), LUAU_INSN_C(insn) - 1, *code++);
                break;

            case LOP_FORNPREP:
                formatAppend(result, "FORNPREP R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORNLOOP:
                formatAppend(result, "FORNLOOP R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORGPREP:
                formatAppend(result, "FORGPREP R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORGLOOP:
                formatAppend(result, "FORGLOOP R%d L%d %d\n", LUAU_INSN_A(insn), targetLabel, *code++);
                break;

            case LOP_FORGPREP_INEXT:
                formatAppend(result, "FORGPREP_INEXT R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORGLOOP_INEXT:
                formatAppend(result, "FORGLOOP_INEXT R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORGPREP_NEXT:
                formatAppend(result, "FORGPREP_NEXT R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FORGLOOP_NEXT:
                formatAppend(result, "FORGLOOP_NEXT R%d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_GETVARARGS:
                formatAppend(result, "GETVARARGS R%d %d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn) - 1);
                break;

            case LOP_DUPCLOSURE:
                formatAppend(result, "DUPCLOSURE R%d K%d%s\n", LUAU_INSN_A(insn), LUAU_INSN_D(insn), getConstant(rl, LUAU_INSN_C(insn), proto).c_str());
                break;

            case LOP_BREAK:
                formatAppend(result, "BREAK\n");
                break;

            case LOP_JUMPBACK:
                formatAppend(result, "JUMPBACK L%d\n", targetLabel);
                break;

            case LOP_LOADKX: { int k = *code++;
                formatAppend(result, "LOADKX R%d K%d%s\n", LUAU_INSN_A(insn), k, getConstant(rl, k, proto).c_str());
                break;
            }

            case LOP_JUMPX:
                formatAppend(result, "JUMPX L%d\n", targetLabel);
                break;

            case LOP_FASTCALL:
                formatAppend(result, "FASTCALL %d L%d\n", LUAU_INSN_A(insn), targetLabel);
                break;

            case LOP_FASTCALL1:
                formatAppend(result, "FASTCALL1 %d R%d L%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), targetLabel);
                break;
            case LOP_FASTCALL2:
            {
                uint32_t aux = *code++;
                formatAppend(result, "FASTCALL2 %d R%d R%d L%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), aux, targetLabel);
                break;
            }
            case LOP_FASTCALL2K:
            {
                uint32_t aux = *code++;
                formatAppend(result, "FASTCALL2K %d R%d K%d L%d\n", LUAU_INSN_A(insn), LUAU_INSN_B(insn), aux, targetLabel);
                break;
            }

            case LOP_COVERAGE:
                formatAppend(result, "COVERAGE\n");
                break;

            case LOP_CAPTURE:
                formatAppend(result, "CAPTURE %s %c%d\n",
                             LUAU_INSN_A(insn) == LCT_UPVAL ? "UPVAL"
                                                            : LUAU_INSN_A(insn) == LCT_REF ? "REF"
                                                                                           : LUAU_INSN_A(insn) == LCT_VAL ? "VAL"
                                                                                                                          : "",
                             LUAU_INSN_A(insn) == LCT_UPVAL ? 'U' : 'R', LUAU_INSN_B(insn));
                break;

            case LOP_JUMPIFEQK:
                formatAppend(result, "JUMPIFEQK R%d K%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_JUMPIFNOTEQK:
                formatAppend(result, "JUMPIFNOTEQK R%d K%d L%d\n", LUAU_INSN_A(insn), *code++, targetLabel);
                break;

            case LOP_NOP:
                formatAppend(result, "NOP\n");
                break;
            default:
                //LUAU_ASSERT(!"Unsupported opcode");
                break;
        }
    }

    /*
        int sizecode = *(int*)(proto + 0xa0);
        uint32_t* code = (uint32_t*)(*(uint64_t*)(proto + 0x20) ^ proto + 0x20);
        std::string result = "";

        std::cout << "[Abyss] Disassembling.\n";
        for (size_t i = 0; i < sizecode;) {
            std::string res;
            dumpInstructionX(rl, &code[i], res, proto, cl, 0);

            uint8_t opdec = LUAU_INSN_OP(code[i]) * 203;
            i += getOpLength(LuauOpcode(opdec));
            result.append(res);
        }

        //std::cout << "[Abyss] Disassembled.\n";
        std::cout << result << "\n";

        dumped_script.append("\n--[[\nDisassembled Script:\n\n");
        dumped_script.append(result);
        dumped_script.append("\n]]");
    */

    void disassemblefunc(uint64_t closure) {
        uint64_t proto = (closure + 0x18) + *(uint64_t*)(closure + 0x18);
        uint32_t* pc = (uint32_t*)((proto + 0x40) ^ *(uint64_t*)(proto + 0x40));
        int sizecode = *(int*)(proto + 0x80);

        while (true) {
            uint8_t op = LUAU_INSN_OP(*pc++) * 203;
            switch (op) {
                case LuauBytecode::LOP_RETURN:
                    std::cout << "[Abyss] End of bytecode.\n";
                    return;
                case LuauBytecode::LOP_NOP:
                    printf("nop\n");
                    break;
                case LuauBytecode::LOP_LOADNIL: {
                    uint32_t insn = *pc++;
                    printf("loadnil r%d\n", LUAU_INSN_A(insn));
                    break;
                }
                default:
                    std::cout << "Unknown Opcode.\n";
            }
            pc++;
        }
    }

    void dumpconstants(uint64_t closure, bool print = true) {
        auto lclosure = (roblox_structs::Closure*)closure;
        uint64_t proto = lclosure->l.p - (uint64_t)&lclosure->l.p;
        roblox_structs::Proto eproto;
        eproto.k = (roblox_structs::TValue*)(*(uint64_t*)(proto + 0x18) - (proto + 0x18));
        eproto.sizek = *(int*)(proto + 0x68);

        auto lproto = &eproto;
        int sizek = lproto->sizek;
        //std::cout << "[Abyss] Successfully Deserialized Proto, Found " << std::dec << sizek << std::hex << " Constants.\n";
        auto constants = lproto->k;
        for (int i = 0; i < sizek; i++) {
            auto constant = constants[i];
            int type = constant.tt;
            //std::cout << "DATA: 0x" << type << "\n";

            switch (type) {
                case LUA_TNUMBER:
                    //if (print) std::cout << "[Abyss] Number: " << constant.value.n << "\n";
                    break;
                case LUA_TSTRING:
                    //if (print) std::cout << "[Abyss] Constant: " << (const char*)(constant.value.gcobject + 0x18) << "\n";
                    {
                        const char* str = (const char*)(constant.value.gcobject + 0x18);
                        if (std::string(str) == "t33eugde") {
                            std::cout << "\n[Abyss] SUCCESSFULLY TRACKED DOWN STRING: " << str << "\nYA\nYA\n\n";
                        }

                        break;
                    }
                case LUA_TFUNCTION: {
                    auto closure = (roblox_structs::Closure*)constant.value.gcobject;
                    bool isC = closure->isC;

                    if (!isC) {
                        //if (print) std::cout << "[Abyss] Closure Begin.\n";
                        dumpconstants((uint64_t)closure, print);
                        //if (print) std::cout << "[Abyss] Closure End.\n";
                    }

                    break;
                }
                default:
                    //if (print) std::cout << "[Abyss] Unknown Constant: " << std::dec << type << std::hex << "\n";
                    break;
            }
        }
    }

    std::string dumped_script_name = "";
    std::string dumped_script = "";

    void dump_script_closure_save() {
        std::string workspace_path = std::string(getenv("HOME")) + "/Documents/";

        std::string script = dumped_script;
        std::string name = dumped_script_name;
        if (!std::filesystem::exists(workspace_path + "Macsploit Dumped")) {
            std::filesystem::create_directory(workspace_path + "Macsploit Dumped");
        }

        std::ofstream file(workspace_path + "Macsploit Dumped/" + name + ".lua");
        file << script;
        file.close();

        std::cout << "[Abyss] Script Saved.\n";
    }

    void dump_script_closure_stub(uint64_t rl, uint64_t proto, int indentation);
    void dump_script_proto(uint64_t rl, uint64_t proto, int indentation) {
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        auto cl = (*rbx_newlclosure)(rl, 0, 0, proto);
        auto top = (roblox_structs::TValue*)rbx_getstacktop(rl);
        top->value.gcobject = (uint64_t)cl;
        top->tt = LUA_TFUNCTION;
        rbx_incrementtop(rl);

        roblox_structs::lua_Debug debug;
        (*rbx_getinfo)(rl, -1, "flnsu", &debug);
        rbx_pop(rl, 2);

        uint8_t numparams = debug.nparams;
        bool is_vararg = debug.isvararg;

        std::string args = "";
        if (numparams > 0 && numparams < 100) {
            for (int i = 1; i < numparams; i++) {
                args.append("arg" + std::to_string(i) + ", ");
            }

            args.append("arg" + std::to_string(numparams));
            if (is_vararg) {
                args.append(", ");
            }
        }

        char buffer[1024];
        if (is_vararg) {
            args.append("...");
        }

        const char* name = "";
        if (debug.name && strcmp(debug.name, ""))
            name = debug.name;

        snprintf(buffer, 1024, "function %s(%s)\n", name, args.c_str());
        dumped_script.append(indent + std::string(buffer));
        dump_script_closure_stub(rl, proto, indentation + 1);
        dumped_script.append(indent + "end\n\n");
    }

    void dump_script_constant(uint64_t rl, roblox_structs::TValue* constant, int indentation) {
        int type = constant->tt;
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        switch (type) {
            case LUA_TTABLE:
            {
                dumped_script.append(indent + "Table {\n");
                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)constant);
                rbx_incrementtop(rl);
                rbx_pushnil(rl);

                int values = 0;
                while ((*rbx_next)(rl, -2)) {
                    if (values) {
                        dumped_script.append("\n");
                    }

                    (*rbx_pushvalue)(rl, -2);
                    dump_script_constant(rl, (roblox_structs::TValue*)rbx_index2addr(rl, -1), indentation + 1);
                    dump_script_constant(rl, (roblox_structs::TValue*)rbx_index2addr(rl, -2), indentation + 1);

                    values++;
                    rbx_pop(rl, 2);
                }

                dumped_script.append(indent + "}\n");
                rbx_pop(rl, 1);
                break;
            }
            case LUA_TFUNCTION:
            {
                auto closure = (roblox_structs::Closure*)constant->value.gcobject;   
                if (!closure->isC) {
                    uint64_t proto = filter_ptr_encryption((uint64_t)&closure->l.p, PROTO_ENC); // PROTO_DEC((uint64_t)&closure->l.p);
                    dump_script_proto(rl, proto, indentation);
                }

                break;
            }
            case LUA_TSTRING:
            {
                uint64_t ts = constant->value.gcobject;
                const char* str = (const char*)(ts + 0x18);
                dumped_script.append(indent + std::string(str) + "\n");
                break;
            }
            case LUA_TNUMBER:
            {
                double num = constant->value.n;
                dumped_script.append(indent + std::to_string(num) + "\n");
                break;
            }
            case LUA_TUSERDATA:
            {
                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)constant);
                rbx_incrementtop(rl);

                (*rbx_getmetatable)(rl, -1);
                (*rbx_getfield)(rl, -1, "__type");
                auto __type = (roblox_structs::TValue*)rbx_index2addr(rl, -1);

                if (__type->tt == LUA_TSTRING) {
                    const char* typestr = rbx_tolstring(rl, -1, nullptr);
                    dumped_script.append(indent + std::string(typestr) + "\n");
                } else {
                    dumped_script.append(indent + "nil\n");
                }

                rbx_pop(rl, 3);
                break;
            }
        }
    }

    void dump_script_closure_stub(uint64_t rl, uint64_t proto, int indentation) {
        int sizep = *(int*)(proto + offsets::proto::sizep);
        std::string indent = "";
        for (int i = 0; i < indentation; i++) {
            indent.append("  ");
        }

        if (sizep) {
            uint64_t* protos = (uint64_t*)filter_ptr_encryption(proto + offsets::proto::protos, PROTOS_ENC);
            for (int i = 0; i < sizep; i++) {
                uint64_t subproto = protos[i];
                dump_script_proto(rl, subproto, indentation);
            }
        }

        int sizek = *(int*)(proto + offsets::proto::sizek);
        auto constants = (roblox_structs::TValue*)(filter_ptr_encryption((proto + offsets::proto::constants), CONSTANT_ENC));
        for (int i = 0; i < sizek; i++) {
            auto constant = constants[i];
            dump_script_constant(rl, &constant, indentation);
        }
    }

    void dump_script_closure(uint64_t rl, std::string source) {
        auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto closure = (roblox_structs::Closure*)tval->value.gcobject;
        uint64_t proto = filter_ptr_encryption((uint64_t)&closure->l.p, PROTO_ENC); // PROTO_DEC((uint64_t)&closure->l.p);

        dumped_script_name = source;
        dumped_script = "-- " + source + "\n\n";

        dump_script_closure_stub(rl, proto, 0);
        std::thread(dump_script_closure_save).detach();
    }

    bool runex(const char* source, uint64_t rl) {
        std::string scriptname(source + 1);
        if (scriptname.find("CmdrClient.Shared.Dispatcher") != std::string::npos) {
            std::cout << "[Abyss] Cmdr Dispatcher Script Executed.\n";
            auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
            auto closure = (roblox_structs::Closure*)tval->value.gcobject;
            uint64_t proto = (uint64_t)&closure->l.p + closure->l.p;

            int sizep = *(int*)(proto + 0x80);
            uint64_t* protos = (uint64_t*)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
            for (int i = 0; i < sizep; i++) {
                uint64_t subproto = protos[i];
                uint64_t debugname = (subproto + 0x48) ^ *(uint64_t*)(subproto + 0x48);

                if (!debugname) continue;
                const char* name = (const char*)(debugname + 0x18);
                if (!strcmp(name, "RunHooks")) {
                    std::cout << "[Abyss] Target Function Identified!\n";
                    /*
                    std::string hook_bytecode = Luau::compile(R"(
                        return function(...)
                            print("C++/Lua Hook Has Been Executed.")
                            return
                        end
                    )");

                    (*rbx_deserialize)(rl, "=Script Abyss.Hook", hook_bytecode.c_str(), hook_bytecode.size(), 0);
                    auto cval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
                    auto cl = (roblox_structs::Closure*)cval->value.gcobject;
                    uint64_t newproto = (uint64_t)&closure->l.p + closure->l.p;
                    std::cout << "[Abyss] Function proto: 0x" << newproto << "\n";
                    protos[i] = newproto;

                    rbx_pop(rl, 1); 
                    std::cout << "[Abyss] Updated Proto.\n"; */
                    auto newclosure = (*rbx_newlclosure)(roblox_thread, 0, 0, subproto);
                    std::cout << "Created NEWLCLOSURE\n";
                    auto topval = (roblox_structs::TValue*)rbx_getstacktop(roblox_thread);
                    topval->value.gcobject = (uint64_t)newclosure;
                    topval->tt = LUA_TFUNCTION;
                    rbx_incrementtop(roblox_thread);

                    std::cout << "[Abyss] Saved Original Proto.\n";
                    (*rbx_setfield)(roblox_thread, LUA_GLOBALSINDEX, "ghookedfunction");
                    std::cout << "[Abyss] Target Proto Saved.\n";
                    return true;
                }
            }
        }

        std::cout << "Function Return.\n";
        return false;
    }

    #define BLACKBIT 2
    #define bitmask(b) (1 << (b))
    #define testbits(x, m) ((x) & (m))
    #define testbit(x, b) testbits(x, bitmask(b))

    bool deserialize_jobscan(uint64_t current_thread) {
        uint64_t scheduler = *(uint64_t*)taskscheduler_address;
        uint64_t start = *(uint64_t*)(scheduler + offsets::jobs_start);
        uint64_t end = *(uint64_t*)(scheduler + offsets::jobs_end);

        while (start < end) {
            auto job = *(scheduler::job**)start;
            scheduler::scheduler_jobs.push_back(job);

            if (job->job_name == "WaitingHybridScriptsJob") {
                const int64_t trigger = 0;
                void** job_address = (void**)job;
                uint64_t script_context = (uint64_t)job_address[offsets::hybridscriptsjob::script_context];
                uint64_t rbx_state = (*rbx_getstate)(script_context, &thread_type, &trigger);
                if (rbx_state == current_thread) return true;
            }

            start += offsets::jobs_offset;
        }

        return false;
    }

    bool join_game = false;
    bool process_scripts = true;
    bool success1 = false;
    int scripts_executed = 0;
    int64_t deserialize_hook(uint64_t rl, const char* source, const char* bytecode, int len, int env) {
        scripts_executed++;
        int64_t result = (*rbx_deserialize)(rl, source, bytecode, len, env);
        if (deserialize_dumpscripts && !result) {
            std::cout << "[Abyss] Dumping: " << (source + 1) << "\n";
            dump_script_closure(rl, source + 1);
        }

        if (!result && deserialize_thread && source) {
            auto thread = *(roblox_structs::GCObject*)deserialize_thread;
            if (thread.tt != LUA_TTHREAD) return result;

            auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
            auto cl = (roblox_structs::Closure*)tval->value.gcobject;

            if (!teleport_event && process_scripts) {
                (*rbx_getfield)(deserialize_thread, LUA_GLOBALSINDEX, "script_buffer");
                auto tvalx = (roblox_structs::TValue*)rbx_index2addr(deserialize_thread, -1);

                if (tvalx->tt == LUA_TTABLE) {
                    const char* script_path = (const char*)(source + 1);
                    int tableidxx = (*rbx_getnum)(tvalx->value.gcobject) + 1;
                    (*rbx_createtable)(deserialize_thread, 4, 0);

                    rbx_pushstring(deserialize_thread, std::string(script_path));
                    (*rbx_rawseti)(deserialize_thread, -2, 1);

                    (*rbx_deserialize)(deserialize_thread, source, bytecode, len, env);
                    (*rbx_rawseti)(deserialize_thread, -2, 2);

                    (*rbx_pushlstring)(deserialize_thread, bytecode, len);
                    (*rbx_rawseti)(deserialize_thread, -2, 3);

                    auto top = (roblox_structs::TValue*)rbx_getstacktop(deserialize_thread);
                    top->value.gcobject = ((roblox_structs::TValue*)rbx_index2addr(rl, LUA_ENVIRONINDEX))->value.gcobject;
                    top->tt = 4;

                    rbx_incrementtop(deserialize_thread);
                    (*rbx_rawseti)(deserialize_thread, -2, 4);

/*
                    auto environ = (roblox_structs::TValue*)rbx_index2addr(rl, LUA_ENVIRONINDEX);
                    auto top = (roblox_structs::TValue*)rbx_getstacktop(deserialize_thread);
                    std::cout << "Environment: 0x" << environ->value.gcobject << "\n";
                    top->value.gcobject = environ->value.gcobject;
                    top->tt = LUA_TTABLE;

                    std::cout << "Stack: 0x" << rbx_gettop(deserialize_thread) << "\n";
                    rbx_incrementtop(deserialize_thread);
                    (*rbx_rawseti)(deserialize_thread, -2, 4);
                    std::cout << "StackRL: 0x" << rbx_gettop(rl) << "\n";
                    std::cout << "Stack: 0x" << rbx_gettop(deserialize_thread) << "\n";
*/

/*
                    auto env2 = (roblox_structs::TValue*)rbx_index2addr(rl, LUA_ENVIRONINDEX);
                    auto top = (roblox_structs::TValue*)rbx_getstacktop(deserialize_thread);

                    top->value.gcobject = env2->value.gcobject;
                    top->tt = LUA_TTABLE;

                    rbx_incrementtop(deserialize_thread);
                    (*rbx_getfield)(deserialize_thread, -1, "script");
                    if (rbx_gettype(deserialize_thread, -1) == LUA_TUSERDATA) {
                        (*rbx_rawseti)(deserialize_thread, -2, 4);
                    } else {
                        std::cout << "Popp\n";
                        rbx_pop(rl, 1);
                    }*/

                    (*rbx_rawseti)(deserialize_thread, -2, tableidxx);
                }

                rbx_pop(deserialize_thread, 1);
            }

            if (deserialize_printscripts) {
                uint64_t retn_address = (uint64_t)__builtin_return_address(0);
                std::cout << "[Load] " << (const char*)(source + 1) << "\n";
                std::cout << "[Load] Returning to 0x" << aslr_bypass(retn_address) << "\n";
            }

            //game_script_dir.push_back(filter_ptr_encryption((uint64_t)&cl->l.p, PROTO_ENC));
            //game_script_map[(source + 1)] = (uint64_t)cl;
        }

        return result;
    }

    /*
        std::cout << "[Abyss] " << source << "\n";
        auto tval = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto closure = (roblox_structs::Closure*)tval->value.gcobject;

        uint64_t proto = (uint64_t)&closure->l.p + closure->l.p;
        int sizelocvars = *(int*)(proto + 0x6C);
        if (!sizelocvars) {
            std::cout << "[Abyss] This script has no local variable information.\n";
        }

        for (int i = 0; i < sizelocvars; i++) {
            uint64_t locvar = *(uint64_t*)(proto + 0x30) + (0x18 * i);
            uint64_t ts = *(uint64_t*)locvar;
            std::cout << std::dec;

            std::cout << "[Abyss] Local Variable " << i << " Name: " << (const char*)(ts + 0x18) << "\n";
            std::cout << std::hex;
        }

        int sizeupvalues = *(int*)(proto + 0x70);
        if (!sizeupvalues) {
            std::cout << "[Abyss] This script has no upvalue information.\n";
        }

        uint64_t* upvalues = (uint64_t*)((proto + 0x10) + *(uint64_t*)(proto + 0x10));
        for (int i = 0; i < sizeupvalues; i++) {
            uint64_t upvalue = upvalues[i];
            std::cout << "[Abyss] Upvalue Name: " << (const char*)(upvalue + 0x18) << "\n";
        }

        int sizep = *(int*)(proto + 0x80);
        if (!sizep) {
            std::cout << "[Abyss] This script has no declared functions.\n";
        }

        uint64_t* protos = (uint64_t*)(*(uint64_t*)(proto + 0x20) + (proto + 0x20));
        for (int i = 0; i < sizep; i++) {
            uint64_t subproto = protos[i];
            uint64_t debugname = (subproto + 0x48) ^ *(uint64_t*)(subproto + 0x48);

            if (debugname) {
                uint8_t numparams = *(uint8_t*)(proto + 0x84);
                bool is_vararg = *(uint8_t*)(proto + 0x87);
                std::string args = "";

                if (numparams > 0) {
                    for (int i = 1; i < numparams; i++) {
                        args.append("arg" + std::to_string(i) + ", ");
                    }

                    args.append("arg" + std::to_string(numparams));
                    if (is_vararg) {
                        args.append(", ");
                    }
                }

                char buffer[1024];
                args.append("...");

                sprintf(buffer, "function %s(%s)\n\nend", (const char*)(debugname + 0x18), args.c_str());
                std::cout << "\n" << buffer << "\n";
            }
        }

    */

    typedef int(* teleport_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3);
    teleport_t rbx_teleport;

    int teleport_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3) {
        std::cout << "\n[Abyss] Game Initiated Teleport...\n";
        std::cout << "[Abyss] Return Address: " << aslr_bypass((uint64_t)__builtin_return_address(0)) << "\n\n";
        if (prevent_server_teleports) {
            return 0;
        }

        teleport_event = true;
        return (*rbx_teleport)(arg1, arg2, arg3);
    }

    std::unordered_map<std::string, bool> gettable_map;
    uint64_t gettable_hook(uint64_t rl, roblox_structs::TValue* t, roblox_structs::TValue* key, roblox_structs::TValue* val, uint64_t arg5) {
        if (key->tt == LUA_TSTRING && *rbx_getidentity(rl) == 8) {
            const char* gettable_key = (const char*)(key->value.gcobject + 0x18);
            int64_t res = (*rbx_gettable)(rl, t, (uint64_t)key, val, arg5);
            
            std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
            
            /*
            if (!strcmp(gettable_key, "TextBox") && val->tt == LUA_TFUNCTION) {
                std::cout << "\nAAA\n\n";
                std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
                int size = rbx_gettop(rl);
                uint64_t cl_addr;
                cl_addr = val->value.gcobject;
                auto cl = (roblox_structs::Closure*)cl_addr;
                uint64_t proto = filter_ptr_encryption((uint64_t)&cl->l.p, PROTO_ENC);
                uint64_t constant = (proto + offsets::proto::constants);
                uint64_t constants = filter_ptr_encryption(constant, CONSTANT_ENC);
                int size_constants = *(int*)(proto + offsets::proto::sizek);
                for (int i = 0; i < size_constants; i++) {
                    auto current_constant = *((roblox_structs::TValue*)constants + i);
                    if (current_constant.tt != LUA_TSTRING) continue;
                    const char* data = (const char*)(current_constant.value.gcobject + 0x18);
                    std::cout << "Dumped Constant: " << data << "\n";
                }

                rbx_setsvalue(rbx_getstacktop(rl), (uint64_t)val);
                rbx_incrementtop(rl);
                (*rbx_spawn)(rl);
                (*rbx_settop)(rl, size);
                return res;
            } */
/*
            if (!gettable_map[gettable_key]) {
                std::cout << "[Gettable] [0x" << rl << "] [0x" << val->tt << "] " << gettable_key << "\n";
                gettable_map[gettable_key] = true;
                return res;
            }
            */
            return res;
            /*
            for (int i = 0; i < rbx_gettop(rl); i++) {
                int idx = -1 - i;
                if (rbx_gettype(rl, idx) == LUA_TSTRING) {
                    std::cout << "[Constant] " << rbx_tolstring(rl, idx, nullptr) << "\n";
                }
            } */
        }

        return (*rbx_gettable)(rl, t, (uint64_t)key, val, arg5);
    }

    uint8_t gettable_bytes[11] = { 0x55, 0x48, 0x89, 0xE5, 0x41, 0x57, 0xE9, 0x0, 0x0, 0x0, 0x0 };
    void hook_gettable(void* hook_func) {
        unsigned char* bytes = (unsigned char*)getfield_address;
        uint64_t gettable_address = 0;
        for (int i = 0; i < 100; i++) {
            if (bytes[i] == 0xE8) {
                uint64_t jaddr = (getfield_address + i);
                int rel = *(int*)(jaddr + 1);
                gettable_address = jaddr + 5 + rel;
            }
        }

        std::cout << gettable_address << "\n";
        uint64_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, 5, VM_FLAGS_ANYWHERE);
        memcpy((void*)tramp_addr, gettable_bytes, sizeof(gettable_bytes));

        int exit_rel_addr = (gettable_address + 0x6) - (tramp_addr + 11);
        *(int*)(tramp_addr + 7) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), tramp_addr, sizeof(gettable_bytes), FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        mach_vm_protect(mach_task_self(), gettable_address, 5, FALSE, VM_PROT_ALL);

        int hook_rel_addr = (uint64_t)hook_func - (gettable_address + 5);
        *(char*)gettable_address = 0xE9;
        *(int*)(gettable_address + 1) = hook_rel_addr;

        mach_vm_protect(mach_task_self(), gettable_address, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        *(uint64_t*)rbx_gettable = tramp_addr;
    }

    /*
    uint8_t getglobal_bytes[19] = { 0x52, 0x50, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x58, 0x4D, 0x8B, 0x44, 0x24, 0x18, 0xE9, 0x00, 0x00, 0x00, 0x00 };
    void hook_getglobal(void* hook_func) {
        uint64_t alloc_address;
        mach_vm_allocate(mach_task_self(), &alloc_address, sizeof(getglobal_bytes), VM_FLAGS_ANYWHERE);
        memcpy((void*)alloc_address, getglobal_bytes, sizeof(getglobal_bytes));

        int hook_rel_addr = (uint64_t)hook_func - (alloc_address + 7);
        *(int*)(alloc_address + 3) = hook_rel_addr;

        int exit_rel_addr = getglobal_exit_addr - (alloc_address + 19);
        *(int*)(alloc_address + 15) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), getglobal_hook_addr, 5, FALSE, VM_PROT_ALL);

        int tramp_rel_addr = alloc_address - (getglobal_hook_addr + 5);
        *(char*)getglobal_hook_addr = 0xE9;
        *(int*)(getglobal_hook_addr + 1) = tramp_rel_addr;

        mach_vm_protect(mach_task_self(), getglobal_hook_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }
    */

    typedef int64_t(*delay_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, double delay);
    delay_t rbx_delay;

    double new_delay = 0.0;
    int64_t delay_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3, double delay) {
        printf("\n[DELAY] Hook Step!\n");
        printf("[DELAY] Supposed Value: %4.2f\n", delay);
        printf("[DELAY] New Value: %4.2f\n\n", new_delay);
        return rbx_delay(arg1, arg2, arg3, new_delay);
    }
    
    typedef int64_t(*concat_t)(uint64_t arg1, uint64_t arg2);
    concat_t rbx_concat;

    void advanced_hook(uint64_t rl, int total, int last) {
        if ((*rbx_gettop)(rl) >= 40 && rbx_gettype(rl, 26) == LUA_TSTRING && rbx_gettype(rl, 27) == LUA_TSTRING) {
            std::string a1 = rbx_tolstring(rl, 26, nullptr);
            std::string a2 = rbx_tolstring(rl, 27, nullptr);
            std::string result = a1 + a2;

            std::cout << "[Collection] " << result << "\n";
            if (result == "Unkown") {
                rbx_pushstring(rl, "Fuck you lol, i, colrealpro, will never let you execute this script!");
                rbx_setsvalue(rbx_index2addr(rl, 26), rbx_index2addr(rl, -1));
                rbx_pop(rl, 1);
            }
        }

        //(*rbx_concat)(rl, total, last);
    }

    void concat_hook2(uint64_t rl, int total, int last) {
        std::cout << "\n[CONCAT] Hook Step!\n";
        int size = (*rbx_gettop)(rl);
        printf("Stack Size: %d\n", size);
        for (int i = 0; i < size; i++) {
            int index = i + 1;
            printf("%d ", index);
            if (rbx_gettype(rl, index) == LUA_TSTRING) {
                std::cout << "[STRING] " << rbx_tolstring(rl, index, nullptr) << "\n";
            } else if (rbx_gettype(rl, index) == LUA_TNUMBER) {
                auto value = (roblox_structs::TValue*)rbx_index2addr(rl, index);   
                std::cout << "[NUMBER] " << std::dec << value->value.n << std::hex << "\n";
            } else {
                printf("\n");
            }
        }

        std::cout << "\n";
        //(*rbx_concat)(rl, total, last);
    }

    void hook_delay() {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(join_body) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_delay = (delay_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t join_addr = apply_aslr(join_address);
        mach_vm_protect(mach_task_self(), join_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)delay_hook - (join_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)join_addr, jmp_bytes, 5);
        *(int*)(join_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), join_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    typedef int64_t(* connect_t)(uint64_t arg1, int64_t arg2, uint64_t arg3, int arg4);
    connect_t rbx_connect;

    typedef void(* command_t)(uint64_t args, std::string script);
    command_t rbx_command;

    uint64_t connect_address = 0x100f621f0;
    uint64_t connect_exit = 0x100f621f6;

    int64_t check_allowed_hook(uint64_t arg1, uint64_t arg2) {
        return true;
    }

    void command_hook(uint64_t args, std::string script) {
        std::cout << "Command hook executed!\n";
        std::cout << "Script: " << script << "\n";
        return rbx_command(args, script);
    }

    int64_t streaming_hook(uint64_t arg1, int64_t arg2, uint64_t arg3, int arg4) {
        std::cout << "[Abyss] Game Streaming Hook Actived!\n"; 
        uint64_t dm = ((uint64_t(*)(uint64_t))apply_aslr(0x101069970))(arg1);
        std::cout << "[Abyss] Game Streaming Enabled: " << (*(bool*)(dm + 0x639) ? "True" : "False") << "\n";

        std::cout << std::dec;
        std::cout << "Target Radius: " << *(int*)(dm + 0x63c) << "\n";
        std::cout << "Min Radius: " << *(int*)(dm + 0x640) << "\n";
        
        int render_distance = 1;
        //*(bool*)(dm + 0x639) = false;
        *(int*)(dm + 0x63c) = render_distance;
        *(int*)(dm + 0x640) = render_distance;

        std::cout << std::hex;
        std::cout << "[Abyss] Spoofed Game Streaming!\n";
        return rbx_connect(arg1, arg2, arg3, arg4);
    }

    int64_t connect_hook(uint64_t rl) {
        std::cout << "\n[Connect] Hooked Connect Function Stepped!\n";
        printf("[Connect] First Argument: 0x%llX\n", rl);

        
        int stacksize = (*rbx_gettop)(rl);
        std::cout << "[Connect] Gettop: 0x" << stacksize << "\n";

        auto udata = (roblox_structs::Udata*)(**(uint64_t**)(rl + offsets::state_base));
        uint64_t data = (uint64_t)&udata->data;
        int64_t* iptr = (int64_t*)data;
        std::string signalname = **(std::string**)(data + 0x28);
        std::cout << "[Connect] Name: " << signalname << "\n";
        std::cout << "[Connect] Unknown: 0x" << iptr[4] << "\n";
        std::cout << "[Connect] Identity: 0x" << static_cast<int>(*rbx_getidentity(rl)) << "\n";
        uint64_t interest = *(uint64_t*)(rl + 0x78);
        std::cout << "[Connect] Sus Pointer: 0x" << *(uint64_t*)(*(uint64_t*)(interest + 0x18) + 8) << "\n";
        printf("[Connect] Unknown Check: %d\n", *(int*)(data + 0x3c));
        ((int64_t(*)())apply_aslr(0x101ae121a))();
        uint64_t* fptr = *(uint64_t**)apply_aslr(0x103552ed8);
        printf("[Connect] fcheck2: 0x%llX\n", aslr_bypass(fptr[1]));
        sleep(1000);

        auto val = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
        auto func = (roblox_structs::Closure*)(val->value.gcobject);
        std::cout << "[Connect] IsC: " << (func->isC ? "true" : "false") << "\n";
        uint64_t proto = func->l.p ^ (uint64_t)&func->l.p;
        uint64_t ts = *(uint64_t*)(proto + 0x20) + (proto + 0x20);
        const char* source = (const char*)(ts + 0x18);
        std::cout << "[Connect] Source: " << source << "\n";
        std::cout << "[Connect] Returning Function...\n\n";
        int64_t result = 0; //rbx_connect(rl, 0); 
        auto val2 = (roblox_structs::TValue*)rbx_index2addr(rl, 3);
        std::cout << "[Connect] Return TT: " << std::dec << val2->tt << std::hex << "\n";
        return result;
    }

    void hook_connect() {
        uint64_t connect_addr = apply_aslr(check_allowed_address);
        mach_vm_protect(mach_task_self(), connect_addr, 5, FALSE, VM_PROT_ALL);

        *(char*)connect_addr = 0xE9;
        *(int*)(connect_addr + 1) = (uint64_t)check_allowed_hook - (connect_addr + 5);

        mach_vm_protect(mach_task_self(), connect_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }

    void hook_teleports() {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(teleport_exit) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_teleport = (teleport_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(teleport_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)teleport_hook - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    typedef int(* namecall_t)(uint64_t rl);
    namecall_t rbx_namecall;

    typedef uint64_t(* fmtcurl_t)(uint64_t arg1, const char* arg2, const char* arg3, const char* arg4, const char* arg5);
    fmtcurl_t rbx_fmtcurl;

    char cookie[2048];
    bool prevent_change = false;
    char roblox_session[2048];
    uint64_t fmtcurl_hook(uint64_t arg1, const char* arg2, const char* arg3, const char* arg4, const char* arg5) {
        if (!strcmp("%s%s=%s", arg2) && (uint64_t)arg5 > 0x600000000000) {
            if (strstr(arg5, "DO-NOT-SHARE") != NULL) {
                arg5 = roblox_session;
            }
        }

        return rbx_fmtcurl(arg1, arg2, arg3, arg4, arg5);
    }

    /*
    int64_t pp_hook(const char* arg1, const char* arg2, const char* arg3, uint64_t arg4, char arg5) {
        std::cout << "\n[Abyss] Hook Activation:\nInstance: " << arg1 << "\nType: " << arg2 << "\nEvent: " << arg3 << "\n\n";
        return rbx_pp(arg1, arg2, arg3, arg4, arg5);
    }*/

    //typedef int64_t(* context_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5);
    typedef int64_t(* context_t)(uint64_t idk, const char* error_type, const char* name_of_thing);
    typedef int64_t(* new_context_t)(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5);
    new_context_t rbx_new_context;
    context_t rbx_context;

    int64_t debug_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing, uint64_t more, uint64_t more2, uint64_t more3, uint64_t padding, uint64_t padding2, uint64_t more4, uint64_t more5) {
        std::cout << "mor1: 0x" << more << "\n";
        std::cout << "mor2: 0x" << more2 << "\n";
        std::cout << "mor3: 0x" << more3 << "\n";
        std::cout << "mor4: 0x" << more4 << "\n";
        std::cout << "mor5: 0x" << more5 << "\n";
        std::cout << "mr4 0x" << rbx_gettop(more) << "\n";
        std::cout << "Hook: " << name_of_thing << " with " << error_type << " error.\n";
        std::cout << "\n[Abyss] Context Triggered, error_type: " << error_type << " name_of_thing: " << name_of_thing << ".\n";
        std::cout << "[Abyss] Return Address: " << aslr_bypass((uint64_t)__builtin_return_address(0)) << "\n\n";
        return 0x10;
    }

    int64_t new_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing) {
        return 0x10;
    }

            /*
        if (!name_of_thing || (strcmp(name_of_thing, "settings") || identity > 7) && (strcmp(name_of_thing, "RobloxLocked") && 
            !(idk == 0x8001 && !strcmp(name_of_thing, "CreatePlugin") && !strcmp(error_type, "call")))) {
            //__tlv_bootstrap
            std::cout << "[Abyss] Context hook called for " << error_type << "!\n[Abyss] Context: 0x" << idk << " Arg: " << name_of_thing << " Identity: 0x" << identity << "\n -> Bypassing...\n";
            return 0x10;


                int64_t old_context_hook(uint64_t identity_flag, const char* error_type, const char* name_of_thing) {
        //100936a45(getidentity(), arg1)
        //uint64_t addr = apply_aslr(0x104551e88);
        //(uint64_t(*)(int*, uint64_t))(apply_aslr(0x100936a45))(global_identity, roblox_thread);
        uint64_t addr = ((uint64_t(*)())apply_aslr(0x10275157c))();
        int identity = *reinterpret_cast<int*>(addr);
        //uint64_t smth = *reinterpret_cast<int64_t*>(addr + 0x18);
        // *reinterpret_cast<int64_t*>(addr + 0x18) = 0x0;
        //std::cout << "Something: 0x" << ((uint64_t(*)(uint64_t))apply_aslr(0x10105001c))(smth) << "\n";
        //std::cout << "0x" << *(uint64_t*)smth << "\n";

        return 0x10; // rbx_context(0x8001, error_type, name_of_thing);

                //100936a45(getidentity(), arg1)
        //uint64_t addr = apply_aslr(0x104551e88);
        //(uint64_t(*)(int*, uint64_t))(apply_aslr(0x100936a45))(global_identity, roblox_thread);
        uint64_t addr = ((uint64_t(*)())apply_aslr(0x10275157c))();
        int identity = *reinterpret_cast<int*>(addr);
        //uint64_t smth = *reinterpret_cast<int64_t*>(addr + 0x18);
        //std::cout << "Something: 0x" << ((uint64_t(*)(uint64_t))apply_aslr(0x10105001c))(smth) << "\n";
        //std::cout << "0x" << *(uint64_t*)smth << "\n";
    }
        }*/

    std::unordered_map<std::string, int> identity_map = {
        { "settings", 3 },
        { "CoreGui", 6 },
        { "RobloxLocked", 6 },
        { "CreatePlugin", 6 },
        { "CorePackages", 6 },
        { "MarketplaceService", -1 }
    };

    std::vector<std::string> exclusions = {
        "CoreGui",
        "CorePackages"
    };

    int64_t old_context_hook(uint64_t idk, const char* error_type, const char* name_of_thing) {
        uint64_t addr = ((uint64_t(*)())apply_aslr(getidentity_address))();
        int identity = *reinterpret_cast<int*>(addr);

        if (!name_of_thing) {
            return rbx_context(idk, error_type, name_of_thing);
        }

        auto safe_pair = identity_map.find(std::string(name_of_thing));
        if (strcmp(error_type, "reparent") && safe_pair != identity_map.end()) {
            if (identity < safe_pair->second) {
                if (settings::get_boolean("sandbox") || std::find(exclusions.begin(), exclusions.end(), name_of_thing) == exclusions.end()) {
                    return rbx_context(idk, error_type, name_of_thing);
                }
            }
        }

        return 0x10;
    }

    int64_t context_hook(uint64_t arg1, uint64_t arg2, uint64_t arg3, const char* arg4, uint64_t arg5) {
        uint64_t rdi_1 = *(uint64_t*)(arg1 + 0x20);
        uint64_t rax_4 = (rdi_1 & arg3);

        const char* str = "";
        if ((uint64_t)arg4 != 0) {
            str = arg4;
        }

        if (!strcmp(str, "access")) {
            std::cout << "top: 0x" << rbx_gettop(arg1) << "\n";
            std::cout << "\n[Abyss] Context hook called for " << str << "!\n[Abyss] Context: 0x" << rax_4 << " Arg: 0x" << arg3 << " -> Bypassing...\n\n";
        }

        if (rax_4 != arg3) {
            return rax_4;
        }

        //return rbx_context(arg1, arg2, arg3, arg4, arg5);
        return 0;
    }

    char create_job_bytes_2[17] = "\x55\x48\x89\xe5\x48\x81\xec\xd0\x00\x00\x00\xe9\x11\x11\x11\x11";
    uint64_t hook_address_2(uint64_t n_addr, void* func) {
        uint64_t namecall_address = n_addr;
        int tramp_len = sizeof(create_job_bytes_2) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes_2, tramp_len);

        int rel_addr = apply_aslr(namecall_address + 11) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(namecall_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        return tramp_addr;
    }

    uint64_t hook_address(uint64_t n_addr, void* func) {
        uint64_t namecall_address = n_addr;
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(namecall_address + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(namecall_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        return tramp_addr;
    }

    //char detection_bytes[45] = "\x51\x48\xB9\x00\x0A\x00\x00\x01\x00\x00\x00\x49\x39\xCF\x4C\x89\xF9\x75\x0A\x48\xB9\xB8\x09\x00\x00\x01\x00\x00\x00\xF3\x0F\x6F\x19\x66\x0F\x38\x40\xD9\x59\xE9\x00\x00\x00\x00";
    //char detection_bytes[45] = "\x51\x48\xB9\x00\x0A\x00\x00\x01\x00\x00\x00\x48\x39\xCB\x48\x89\xD9\x75\x0A\x48\xB9\xB8\x09\x00\x00\x01\x00\x00\x00\xF3\x0F\x6F\x09\x66\x0F\x38\x40\xCA\x59\xE9\x00\x00\x00\x00"; (rbx)

    uint64_t hook_detection_1() {
        char detection_bytes[45] = "\x51\x48\xB9\x00\x0A\x00\x00\x01\x00\x00\x00\x49\x39\xCF\x4C\x89\xF9\x75\x0A\x48\xB9\xB8\x09\x00\x00\x01\x00\x00\x00\xF3\x0F\x6F\x19\x66\x0F\x38\x40\xD9\x59\xE9\x00\x00\x00\x00";
        int hook_size = sizeof(detection_bytes) - 1;

        mach_vm_address_t hook_addr;
        mach_vm_allocate(mach_task_self(), &hook_addr, hook_size, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), hook_addr, hook_size, FALSE, VM_PROT_ALL);
        memcpy((void*)hook_addr, detection_bytes, hook_size);

        int rel_addr = apply_aslr(detection1_address + 10) - (hook_addr + hook_size);
        *(int*)(hook_addr + hook_size - 4) = rel_addr;
        mach_vm_protect(mach_task_self(), hook_addr, hook_size, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t detection_addr = apply_aslr(detection1_address);
        mach_vm_protect(mach_task_self(), detection_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = hook_addr - (detection_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)detection_addr, jmp_bytes, 5);
        *(int*)(detection_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), detection_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
        return hook_addr;
    }

    void safe_hook_context(context_t func) {
        int tramp_len = sizeof(create_job_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, create_job_bytes, tramp_len);

        int rel_addr = apply_aslr(context_address + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_context = (context_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(context_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)func - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }

    void hook_context() {
        uint64_t context_addr = apply_aslr(context_address);
        mach_vm_protect(mach_task_self(), context_addr, 5, FALSE, VM_PROT_ALL);

        *(char*)context_addr = 0xE9;
        *(int*)(context_addr + 1) = (uint64_t)debug_context_hook - (context_addr + 5);

        mach_vm_protect(mach_task_self(), context_addr, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    }

    void hook_deserialize(deserialize_t hook_func) {
        mach_vm_address_t tramp_addr;
        deserialize_exit = apply_aslr(deserialize_exit);
        mach_vm_allocate(mach_task_self(), &tramp_addr, hook_len, VM_FLAGS_ANYWHERE);
        memcpy((void*)tramp_addr, deserialize_bytes, hook_len);

        int exit_rel_addr = deserialize_exit - (tramp_addr + hook_len);
        *(int*)(tramp_addr + (hook_len - 4)) = exit_rel_addr;

        mach_vm_protect(mach_task_self(), deserialize_address, 5, FALSE, VM_PROT_ALL);
        mach_vm_protect(mach_task_self(), tramp_addr, hook_len, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);

        *(char*)deserialize_address = 0xE9;
        uint64_t hook_rel_addr = (uint64_t)hook_func - (deserialize_address + 5);
        *(int*)(deserialize_address + 1) = hook_rel_addr;

        mach_vm_protect(mach_task_self(), deserialize_address, 5, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
        *(uint64_t*)rbx_deserialize = tramp_addr;
    }

    typedef uint64_t(* private_t)(uint64_t d8, const char* arg2, uint64_t arg3);
    bool debug_private = false;
    private_t rbx_private;

    uint64_t private_hook(uint64_t json, const char* name, int64_t num) {
        uint64_t retn_address = (uint64_t)__builtin_return_address(0); //0x08558b49 (rbx)
        if (!strcmp(name, "placeId") && *(int*)retn_address != 0x08568b49 && settings::get_boolean("placeRestrictions")) {
            if (debug_private) { std::cout << "\n[Abyss] Private Hook Activation Record!\n[Abyss] Successfully Modified Value.\n\n"; }
            auto append_bool = reinterpret_cast<uint64_t(*)(uint64_t, const char*, int)>(apply_aslr(appendbool_address));
            append_bool(json, "isTeleport", 1);
            return rbx_private(json, name, num);
        }

        if (debug_private) { std::cout << "[Abyss] Returning Hook for " << name << "...\n"; }
        return rbx_private(json, name, num);
    }

    void hook_private() {
        int tramp_len = sizeof(connect_bytes) - 1;
        mach_vm_address_t tramp_addr;
        mach_vm_allocate(mach_task_self(), &tramp_addr, tramp_len, VM_FLAGS_ANYWHERE);
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_ALL);
        memcpy((void*)tramp_addr, connect_bytes, tramp_len);

        int rel_addr = apply_aslr(private_address + 0x6) - (tramp_addr + tramp_len);
        *(int*)(tramp_addr + tramp_len - 4) = rel_addr;
        rbx_private = (private_t)tramp_addr;
        mach_vm_protect(mach_task_self(), tramp_addr, tramp_len, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);

        uint64_t concat_addr = apply_aslr(private_address);
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_ALL);
        int hook_rel_addr = (uint64_t)private_hook - (concat_addr + 5);
        uint8_t jmp_bytes[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

        memcpy((void*)concat_addr, jmp_bytes, 5);
        *(int*)(concat_addr + 1) = hook_rel_addr;
        mach_vm_protect(mach_task_self(), concat_addr, 5, FALSE, VM_PROT_EXECUTE | VM_PROT_READ);
    }
}

#endif //CLIENT_EXPLOIT_H
